<!--
tags: #テスト #品質保証 #開発プロセス #テスト戦略 #ユニットテスト #E2Eテスト #Storybook #コンポーネントテスト #TDD #品質基準 #Vitest #Playwright #React Testing Library #MSW #重要 #完了
category: 品質保証
priority: 高
status: 完了
last_updated: 2025-01-13
test_frameworks: ["Vitest", "Playwright", "Storybook", "React Testing Library"]
coverage_target: 80
-->

# テストガイド - Saifuu Frontend

## 概要

このドキュメントは、Saifuu フロントエンドプロジェクトにおけるテストの実装方針と使用方法を説明します。

## テスト戦略の変遷

### 現在の戦略（2025年1月〜）

VRT(Visual Regression Testing)システムを削除し、以下の3層構造による品質担保に移行しました：

- **Storybookコンポーネントテスト**: UIの状態・インタラクション確認
- **ユニットテスト**: ロジック・バリデーション・エラーハンドリング
- **最小限のE2Eテスト**: 正常系の主要ユーザーフロー

**詳細な背景**: [ADR-001: VRTシステムの削除](./adr/001-remove-vrt-system.md)

### 変更理由

- Chromaticなしでは真のビジュアルテストが困難
- DOM依存のテストに留まり、期待効果を得られない
- 運用コストが品質向上効果を上回る

現在の戦略は、各テスト手法の特性を活かした効率的な品質担保を目指しています。

## テスト戦略

### テスト駆動開発（TDD）の原則

プロジェクトではKent BeckのTDD（Test-Driven Development）に厳密に従って開発を進めます。

#### Red-Green-Refactorサイクル
1. **Red（赤）**: 最初に失敗するテストを書く
   - 実装する機能の小さな増分を定義する最もシンプルなテストを作成
   - 動作を説明する意味のあるテスト名を使用
   - テストの失敗が明確で有益な情報を提供することを確認

2. **Green（緑）**: テストをパスする最小限のコードを実装
   - テストをパスするのに必要な最小限のコードのみを書く
   - 過度な一般化や未来の要件への対応は避ける
   - すべてのテストがパスすることを確認

3. **Refactor（リファクタリング）**: コードの品質を改善
   - テストがパスした状態を維持しながら構造を改善
   - 重複を排除し、明確性を向上させる
   - 各リファクタリングステップ後にテストを実行

### 砂時計型テスト戦略

プロジェクトでは砂時計型アプローチを採用し、ユニットテストと統合テストに重点を置いています：

```
E2Eテスト (最小限)               ━━━━━  
                              ╱      ╲
統合テスト (API/DB連携)        ╱          ╲  ← 幅広くカバー
                         ╱              ╲
                        ╲                ╱
ユニットテスト (ロジック)        ╲          ╱  ← 重点的に実装
                              ╲      ╱
スモークテスト (最小限)          ━━━━━
```

### テストピラミッド（実装方針）

```
E2Eテスト (Playwright)          # 正常系のみ・最小限
    ↑
ストーリーテスト (Storybook)      # コンポーネントテスト  
    ↑
ユニットテスト (Vitest)          # 単体テスト・エラー系
```

### 責務分担

- **Vitest**: ロジック・ユーティリティ関数・バリデーション・エラーハンドリング
- **Storybook**: コンポーネント表示・インタラクション・レスポンシブ
- **Playwright**: 正常系の主要ユーザーフローのみ
- **統合テスト**: APIエンドポイントとデータベースの連携を網羅的にテスト

### Tidy Firstアプローチ

すべての変更を2つのタイプに明確に分類：

1. **構造的変更（Structure）**
   - 動作を変更せずにコードを再配置
   - 例：名前の変更、メソッドの抽出、コードの移動
   - 構造変更後もすべてのテストがパスすることを確認

2. **動作変更（Behavior）**
   - 実際の機能の追加または変更
   - 新しいテストケースが必要
   - 構造的変更とは別のコミットで行う

## 技術スタック

### テストフレームワーク
- **Vitest**: 高速なユニットテストランナー
- **React Testing Library**: Reactコンポーネントテスト
- **Playwright**: E2Eテスト（最小限）
- **Storybook**: コンポーネント分離開発・視覚的テスト

### テストユーティリティ
- **@testing-library/user-event**: ユーザーインタラクションシミュレーション
- **@faker-js/faker**: リアルなテストデータ生成
- **MSW (Mock Service Worker)**: APIモック
- **@testing-library/jest-dom**: 追加のアサーション

## テストユーティリティ

### カスタムレンダリング関数

```typescript
// test-utils/custom-render.tsx
import { render } from '@/test-utils';

// プロバイダーを自動的に適用
const MyComponent = () => <div>Test</div>;
render(<MyComponent />);
```

### モックデータファクトリー

```typescript
// test-utils/mock-factories.ts
import { createMockSubscription, createMockCategories } from '@/test-utils';

// 単一のモックデータ
const subscription = createMockSubscription();

// 複数のモックデータ
const categories = createMockCategories(5);

// カスタムプロパティ
const customSubscription = createMockSubscription({
  name: 'Netflix',
  amount: 1200,
});
```

### MSWハンドラー

```typescript
// test-utils/msw-handlers.ts
import { createSuccessHandlers, createErrorHandlers } from '@/test-utils';

// 成功レスポンス
const successHandlers = createSuccessHandlers();

// エラーレスポンス
const errorHandlers = createErrorHandlers();
```

## テストパターン

### 基本的なテスト構造

```typescript
// コンポーネント名.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@/test-utils';
import userEvent from '@testing-library/user-event';
import ComponentName from './ComponentName';

describe('ComponentName', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('基本レンダリング', () => {
    it('正常にレンダリングされる', () => {
      render(<ComponentName />);
      
      expect(screen.getByText('期待されるテキスト')).toBeInTheDocument();
    });
  });

  describe('プロパティテスト', () => {
    it('プロパティが正しく適用される', () => {
      render(<ComponentName title="テストタイトル" />);
      
      expect(screen.getByText('テストタイトル')).toBeInTheDocument();
    });
  });

  describe('インタラクション', () => {
    it('ボタンクリックが正しく動作する', async () => {
      const user = userEvent.setup();
      const mockHandler = vi.fn();
      
      render(<ComponentName onClick={mockHandler} />);
      
      await user.click(screen.getByRole('button'));
      
      expect(mockHandler).toHaveBeenCalledTimes(1);
    });
  });

  describe('エラーハンドリング', () => {
    it('エラー時に適切なメッセージが表示される', () => {
      render(<ComponentName error="エラーメッセージ" />);
      
      expect(screen.getByText('エラーメッセージ')).toBeInTheDocument();
    });
  });

  describe('アクセシビリティ', () => {
    it('適切なARIA属性が設定される', () => {
      render(<ComponentName />);
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('aria-label', '期待されるラベル');
    });
  });
});
```

### 非同期処理のテスト

```typescript
it('非同期処理が正しく動作する', async () => {
  const user = userEvent.setup();
  
  render(<AsyncComponent />);
  
  await user.click(screen.getByRole('button'));
  
  // ローディング状態の確認
  expect(screen.getByText('読み込み中...')).toBeInTheDocument();
  
  // 結果の確認
  await waitFor(() => {
    expect(screen.getByText('完了しました')).toBeInTheDocument();
  });
});
```

### MSWを使用したAPIテスト

```typescript
import { server } from '@/test-utils/msw-server';
import { createErrorHandlers } from '@/test-utils';

it('API エラー時の処理', async () => {
  // エラーハンドラーを設定
  server.use(...createErrorHandlers());
  
  render(<ApiComponent />);
  
  await waitFor(() => {
    expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();
  });
});
```

## テストの実行

### 基本コマンド

```bash
# 全てのテストを実行
pnpm run test:unit

# ウォッチモードで実行
pnpm run test:unit -- --watch

# カバレッジレポート付きで実行
pnpm run test:unit -- --coverage

# 特定のファイルのみ実行
pnpm run test:unit -- ComponentName.test.tsx
```

### テストの設定

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
    exclude: [
      'node_modules/**',
      'dist/**',
      '**/__tests__/helpers/**',  // テストヘルパーファイルを除外
    ],
    coverage: {
      exclude: [
        '**/__tests__/helpers/**',  // カバレッジからも除外
        // その他の除外パターン
      ],
      threshold: {
        branches: 80,
        functions: 80,
        lines: 80,
        statements: 80,
      },
    },
  },
});
```

### テストヘルパーファイルの管理

テストヘルパーファイル（フィクスチャ、モックデータ、ユーティリティ関数など）は、`__tests__/helpers/` ディレクトリに配置し、自動的にテスト実行対象とカバレッジ計測から除外されます。

```
src/__tests__/
├── unit/                    # ユニットテスト
├── integration/             # 統合テスト
└── helpers/                 # テストヘルパー（テスト対象外）
    ├── fixtures.ts          # テストデータ
    ├── test-utils.ts        # テストユーティリティ
    └── mock-data.ts         # モックデータ
```

## ベストプラクティス

### 1. テストの命名規則

- `describe`: コンポーネント名や機能名
- `it`: 「〜が〜する」形式で期待される動作を明確に記述
- 日本語でのテスト説明を推奨

### 2. テストの構造

```typescript
describe('ComponentName', () => {
  describe('基本レンダリング', () => {
    // レンダリング関連のテスト
  });
  
  describe('プロパティテスト', () => {
    // プロパティ関連のテスト
  });
  
  describe('インタラクション', () => {
    // ユーザーインタラクション関連のテスト
  });
  
  describe('エラーハンドリング', () => {
    // エラー処理関連のテスト
  });
  
  describe('アクセシビリティ', () => {
    // アクセシビリティ関連のテスト
  });
});
```

### 3. クエリの優先順位

Testing Library のクエリを優先順位に従って使用：

1. **getByRole** - アクセシビリティ重視
2. **getByLabelText** - フォーム要素用
3. **getByText** - テキスト内容での取得
4. **getByTestId** - 最後の手段

```typescript
// 推奨
screen.getByRole('button', { name: 'サブスクリプションを追加' });

// 非推奨
screen.getByTestId('add-subscription-button');
```

### 4. アサーションの書き方

```typescript
// 良い例
expect(screen.getByText('エラーメッセージ')).toBeInTheDocument();

// 悪い例
expect(screen.getByText('エラーメッセージ')).toBeTruthy();
```

### 5. モックの使用

```typescript
// 必要最小限のモック
vi.mock('@/lib/api/client', () => ({
  fetchSubscriptions: vi.fn(),
}));

// 過度なモックは避ける
// 実際のコンポーネントの挙動をテストする
```

## トラブルシューティング

### よくある問題と解決策

#### 1. act() warning が出る場合

```typescript
// 悪い例
fireEvent.click(button);

// 良い例
await user.click(button);
```

#### 2. 非同期処理でのタイムアウト

```typescript
// waitFor のタイムアウト設定
await waitFor(() => {
  expect(screen.getByText('完了')).toBeInTheDocument();
}, { timeout: 5000 });
```

#### 3. MSW でのリクエスト マッチング

```typescript
// 正確なURL マッチング
http.get(`${API_BASE_URL}/subscriptions`, () => {
  return HttpResponse.json({ subscriptions: [] });
});
```

## カバレッジ目標

- **ブランチカバレッジ**: 80%以上
- **関数カバレッジ**: 80%以上
- **行カバレッジ**: 80%以上
- **文カバレッジ**: 80%以上

## オーバーテスト防止ガイドライン

### 概要

過剰なテストは保守性を損ない、開発効率を低下させます。このガイドラインは、適切なテスト量を維持し、効果的な品質保証を実現するための基準を定めています。

### テストコード量の基準

コンポーネントの複雑度に応じて、テストコード量の上限を設定します：

#### シンプルなコンポーネント（100行未満）
- **テストコード量**: 最大1.5倍まで
- **対象**: 表示専用コンポーネント、単純なフォーム要素
- **テスト内容**: 基本レンダリング、プロパティテスト、最小限のインタラクション

#### 中規模コンポーネント（100-300行）
- **テストコード量**: 最大2倍まで
- **対象**: 状態管理を含むコンポーネント、複数の子コンポーネントを持つコンテナ
- **テスト内容**: 上記に加えて、状態変更、エラーハンドリング、主要なエッジケース

#### 大規模コンポーネント（300行以上）
- **テストコード量**: 最大2.5倍まで
- **対象**: 複雑なビジネスロジックを含むコンポーネント、フォーム全体
- **テスト内容**: 網羅的なテストケース、統合的な動作確認

### オーバーテストの兆候

以下の状況は、過剰なテストの可能性を示しています：

1. **実装の詳細に依存したテスト**
   - 内部の状態管理の詳細をテスト
   - プライベートメソッドの直接テスト
   - DOM構造の詳細な検証

2. **重複したテストケース**
   - 同じ動作を異なる角度から繰り返しテスト
   - 既にStorybookでカバーされている視覚的な確認

3. **価値の低いテスト**
   - サードパーティライブラリの動作確認
   - 型システムで保証される内容のテスト
   - 些末な実装詳細のテスト

### 効果的なテスト作成のガイドライン

1. **ユーザー視点でテストを書く**
   ```typescript
   // 良い例：ユーザーの操作をテスト
   it('フォーム送信時に登録処理が実行される', async () => {
     await user.type(screen.getByLabelText('金額'), '1000');
     await user.click(screen.getByRole('button', { name: '登録' }));
     expect(mockSubmit).toHaveBeenCalledWith({ amount: 1000 });
   });

   // 悪い例：実装の詳細をテスト
   it('入力時にsetStateが呼ばれる', () => {
     // 実装の詳細に依存したテスト
   });
   ```

2. **境界値と異常系に注力**
   - 正常系は最小限に
   - エラーケースとエッジケースを重点的にテスト
   - バリデーションロジックは網羅的に

3. **テストの重複を避ける**
   - Storybookでカバーされる視覚的確認は省略
   - 型で保証される内容はテスト不要
   - 上位コンポーネントでテストされる動作は省略

### モニタリングと改善

1. **定期的なレビュー**
   - 四半期ごとにテストコード量の比率を確認
   - 実行時間が長いテストの見直し
   - 失敗頻度の高いテストの改善

2. **継続的な最適化**
   - 新規開発時は基準に従ってテストを作成
   - リファクタリング時に過剰なテストを削減
   - チーム全体で基準を共有し、レビューで確認

## 継続的改善

1. **テストレビュー**: PRレビュー時にテストの品質も確認
2. **定期的な見直し**: テストの実行時間やカバレッジを定期的に確認
3. **エラー分析**: 失敗したテストから学び、テスト改善に活用
4. **新機能対応**: 新機能追加時は必ずテストも追加
5. **オーバーテスト防止**: テストコード量の基準を遵守し、価値の高いテストに注力

## 関連ドキュメント

- [テストケース分析](./テストケース分析.md) - 既存テストケースの分析結果
- [ADR-001: VRTシステムの削除](../adr/001-remove-vrt-system.md) - テスト戦略の背景

## 参考資料

- [Testing Library](https://testing-library.com/)
- [Vitest](https://vitest.dev/)
- [MSW](https://mswjs.io/)
- [Storybook](https://storybook.js.org/)
- [Playwright](https://playwright.dev/)