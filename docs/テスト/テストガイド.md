<!--
tags: #テスト #品質保証 #開発プロセス #テスト戦略 #ユニットテスト #E2Eテスト #Storybook #コンポーネントテスト #TDD #品質基準 #Vitest #Playwright #React Testing Library #MSW #重要 #完了
category: 品質保証
priority: 高
status: 完了
last_updated: 2025-01-13
test_frameworks: ["Vitest", "Playwright", "Storybook", "React Testing Library"]
coverage_target: 80
-->

# テストガイド - Saifuu Frontend

## 概要

このドキュメントは、Saifuu フロントエンドプロジェクトにおけるテストの実装方針と使用方法を説明します。

## テスト戦略の変遷

### 現在の戦略（2025年1月〜）

VRT(Visual Regression Testing)システムを削除し、以下の3層構造による品質担保に移行しました：

- **Storybookコンポーネントテスト**: UIの状態・インタラクション確認
- **ユニットテスト**: ロジック・バリデーション・エラーハンドリング
- **最小限のE2Eテスト**: 正常系の主要ユーザーフロー

**詳細な背景**: [ADR-001: VRTシステムの削除](./adr/001-remove-vrt-system.md)

### 変更理由

- Chromaticなしでは真のビジュアルテストが困難
- DOM依存のテストに留まり、期待効果を得られない
- 運用コストが品質向上効果を上回る

現在の戦略は、各テスト手法の特性を活かした効率的な品質担保を目指しています。

## テスト戦略

### テスト駆動開発（TDD）の原則

プロジェクトではKent BeckのTDD（Test-Driven Development）に厳密に従って開発を進めます。

#### Red-Green-Refactorサイクル
1. **Red（赤）**: 最初に失敗するテストを書く
   - 実装する機能の小さな増分を定義する最もシンプルなテストを作成
   - 動作を説明する意味のあるテスト名を使用
   - テストの失敗が明確で有益な情報を提供することを確認

2. **Green（緑）**: テストをパスする最小限のコードを実装
   - テストをパスするのに必要な最小限のコードのみを書く
   - 過度な一般化や未来の要件への対応は避ける
   - すべてのテストがパスすることを確認

3. **Refactor（リファクタリング）**: コードの品質を改善
   - テストがパスした状態を維持しながら構造を改善
   - 重複を排除し、明確性を向上させる
   - 各リファクタリングステップ後にテストを実行

### 砂時計型テスト戦略

プロジェクトでは砂時計型アプローチを採用し、ユニットテストと統合テストに重点を置いています：

```
E2Eテスト (最小限)               ━━━━━  
                              ╱      ╲
統合テスト (API/DB連携)        ╱          ╲  ← 幅広くカバー
                         ╱              ╲
                        ╲                ╱
ユニットテスト (ロジック)        ╲          ╱  ← 重点的に実装
                              ╲      ╱
スモークテスト (最小限)          ━━━━━
```

### テストピラミッド（実装方針）

```
E2Eテスト (Playwright)          # 正常系のみ・最小限
    ↑
ストーリーテスト (Storybook)      # コンポーネントテスト  
    ↑
ユニットテスト (Vitest)          # 単体テスト・エラー系
```

### 責務分担

- **Vitest**: ロジック・ユーティリティ関数・バリデーション・エラーハンドリング
- **Storybook**: コンポーネント表示・インタラクション・レスポンシブ
- **Playwright**: 正常系の主要ユーザーフローのみ
- **統合テスト**: APIエンドポイントとデータベースの連携を網羅的にテスト

### Tidy Firstアプローチ

すべての変更を2つのタイプに明確に分類：

1. **構造的変更（Structure）**
   - 動作を変更せずにコードを再配置
   - 例：名前の変更、メソッドの抽出、コードの移動
   - 構造変更後もすべてのテストがパスすることを確認

2. **動作変更（Behavior）**
   - 実際の機能の追加または変更
   - 新しいテストケースが必要
   - 構造的変更とは別のコミットで行う

## 技術スタック

### テストフレームワーク
- **Vitest**: 高速なユニットテストランナー
- **React Testing Library**: Reactコンポーネントテスト
- **Playwright**: E2Eテスト（最小限）
- **Storybook**: コンポーネント分離開発・視覚的テスト

### テストユーティリティ
- **@testing-library/user-event**: ユーザーインタラクションシミュレーション
- **@faker-js/faker**: リアルなテストデータ生成
- **MSW (Mock Service Worker)**: APIモック
- **@testing-library/jest-dom**: 追加のアサーション

## テストユーティリティ

### カスタムレンダリング関数

```typescript
// test-utils/custom-render.tsx
import { render } from '@/test-utils';

// プロバイダーを自動的に適用
const MyComponent = () => <div>Test</div>;
render(<MyComponent />);
```

### モックデータファクトリー

```typescript
// test-utils/mock-factories.ts
import { createMockSubscription, createMockCategories } from '@/test-utils';

// 単一のモックデータ
const subscription = createMockSubscription();

// 複数のモックデータ
const categories = createMockCategories(5);

// カスタムプロパティ
const customSubscription = createMockSubscription({
  name: 'Netflix',
  amount: 1200,
});
```

### MSWハンドラー

```typescript
// test-utils/msw-handlers.ts
import { createSuccessHandlers, createErrorHandlers } from '@/test-utils';

// 成功レスポンス
const successHandlers = createSuccessHandlers();

// エラーレスポンス
const errorHandlers = createErrorHandlers();
```

## テストパターン

### 基本的なテスト構造

```typescript
// コンポーネント名.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@/test-utils';
import userEvent from '@testing-library/user-event';
import ComponentName from './ComponentName';

describe('ComponentName', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('基本レンダリング', () => {
    it('正常にレンダリングされる', () => {
      render(<ComponentName />);
      
      expect(screen.getByText('期待されるテキスト')).toBeInTheDocument();
    });
  });

  describe('プロパティテスト', () => {
    it('プロパティが正しく適用される', () => {
      render(<ComponentName title="テストタイトル" />);
      
      expect(screen.getByText('テストタイトル')).toBeInTheDocument();
    });
  });

  describe('インタラクション', () => {
    it('ボタンクリックが正しく動作する', async () => {
      const user = userEvent.setup();
      const mockHandler = vi.fn();
      
      render(<ComponentName onClick={mockHandler} />);
      
      await user.click(screen.getByRole('button'));
      
      expect(mockHandler).toHaveBeenCalledTimes(1);
    });
  });

  describe('エラーハンドリング', () => {
    it('エラー時に適切なメッセージが表示される', () => {
      render(<ComponentName error="エラーメッセージ" />);
      
      expect(screen.getByText('エラーメッセージ')).toBeInTheDocument();
    });
  });

  describe('アクセシビリティ', () => {
    it('適切なARIA属性が設定される', () => {
      render(<ComponentName />);
      
      const button = screen.getByRole('button');
      expect(button).toHaveAttribute('aria-label', '期待されるラベル');
    });
  });
});
```

### 非同期処理のテスト

```typescript
it('非同期処理が正しく動作する', async () => {
  const user = userEvent.setup();
  
  render(<AsyncComponent />);
  
  await user.click(screen.getByRole('button'));
  
  // ローディング状態の確認
  expect(screen.getByText('読み込み中...')).toBeInTheDocument();
  
  // 結果の確認
  await waitFor(() => {
    expect(screen.getByText('完了しました')).toBeInTheDocument();
  });
});
```

### MSWを使用したAPIテスト

```typescript
import { server } from '@/test-utils/msw-server';
import { createErrorHandlers } from '@/test-utils';

it('API エラー時の処理', async () => {
  // エラーハンドラーを設定
  server.use(...createErrorHandlers());
  
  render(<ApiComponent />);
  
  await waitFor(() => {
    expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();
  });
});
```

## テストの実行

### 基本コマンド

```bash
# 全てのテストを実行
npm run test:unit

# ウォッチモードで実行
npm run test:unit -- --watch

# カバレッジレポート付きで実行
npm run test:unit -- --coverage

# 特定のファイルのみ実行
npm run test:unit -- ComponentName.test.tsx
```

### テストの設定

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'],
    coverage: {
      threshold: {
        branches: 80,
        functions: 80,
        lines: 80,
        statements: 80,
      },
    },
  },
});
```

## ベストプラクティス

### 1. テストの命名規則

- `describe`: コンポーネント名や機能名
- `it`: 「〜が〜する」形式で期待される動作を明確に記述
- 日本語でのテスト説明を推奨

### 2. テストの構造

```typescript
describe('ComponentName', () => {
  describe('基本レンダリング', () => {
    // レンダリング関連のテスト
  });
  
  describe('プロパティテスト', () => {
    // プロパティ関連のテスト
  });
  
  describe('インタラクション', () => {
    // ユーザーインタラクション関連のテスト
  });
  
  describe('エラーハンドリング', () => {
    // エラー処理関連のテスト
  });
  
  describe('アクセシビリティ', () => {
    // アクセシビリティ関連のテスト
  });
});
```

### 3. クエリの優先順位

Testing Library のクエリを優先順位に従って使用：

1. **getByRole** - アクセシビリティ重視
2. **getByLabelText** - フォーム要素用
3. **getByText** - テキスト内容での取得
4. **getByTestId** - 最後の手段

```typescript
// 推奨
screen.getByRole('button', { name: 'サブスクリプションを追加' });

// 非推奨
screen.getByTestId('add-subscription-button');
```

### 4. アサーションの書き方

```typescript
// 良い例
expect(screen.getByText('エラーメッセージ')).toBeInTheDocument();

// 悪い例
expect(screen.getByText('エラーメッセージ')).toBeTruthy();
```

### 5. モックの使用

```typescript
// 必要最小限のモック
vi.mock('@/lib/api/client', () => ({
  fetchSubscriptions: vi.fn(),
}));

// 過度なモックは避ける
// 実際のコンポーネントの挙動をテストする
```

## トラブルシューティング

### よくある問題と解決策

#### 1. act() warning が出る場合

```typescript
// 悪い例
fireEvent.click(button);

// 良い例
await user.click(button);
```

#### 2. 非同期処理でのタイムアウト

```typescript
// waitFor のタイムアウト設定
await waitFor(() => {
  expect(screen.getByText('完了')).toBeInTheDocument();
}, { timeout: 5000 });
```

#### 3. MSW でのリクエスト マッチング

```typescript
// 正確なURL マッチング
http.get(`${API_BASE_URL}/subscriptions`, () => {
  return HttpResponse.json({ subscriptions: [] });
});
```

## カバレッジ目標

- **ブランチカバレッジ**: 80%以上
- **関数カバレッジ**: 80%以上
- **行カバレッジ**: 80%以上
- **文カバレッジ**: 80%以上

## オーバーテスト防止ガイドライン

### 概要

高品質なテストを維持しながら、過度なテストによる開発効率の低下を防ぐためのガイドラインです。

### コンポーネント複雑度別テスト基準

#### 1. シンプルコンポーネント（100行未満）
- **テストコード量**: ソースコードの0.5〜1.5倍
- **テスト項目**: 基本的なレンダリング、プロパティ、主要インタラクション
- **例**: ボタン、ラベル、シンプルな表示コンポーネント

#### 2. 中規模コンポーネント（100〜400行）
- **テストコード量**: ソースコードの1〜2倍
- **テスト項目**: 全プロパティ、状態遷移、エラーハンドリング、アクセシビリティ
- **例**: フォーム、モーダル、データ表示コンポーネント

#### 3. 複雑コンポーネント（400行以上）
- **テストコード量**: ソースコードの1.5〜2.5倍
- **テスト項目**: 包括的なシナリオテスト、エッジケース、パフォーマンス考慮
- **例**: ダッシュボード、複雑なフィルター機能、データグリッド

### 警告基準

⚠️ **テストコード量がソースコード量の3倍を超えた場合は要見直し**

### Storybookストーリー最適化

#### ストーリー作成基準
- **基本ストーリー**: Default, Loading, Error, Empty（該当する場合）
- **追加ストーリー**: 複雑度に応じて5〜10個まで
- **重複回避**: 同じ状態を異なる角度から見せるストーリーは統合

#### ストーリー削減の判断基準
1. 同じプロパティの組み合わせをテストしている
2. 視覚的な差がほとんどない
3. ユニットテストでカバーできる内容

### テスト種別の使い分け

#### ユニットテストで十分なケース
- ユーティリティ関数
- 純粋な計算ロジック
- バリデーション
- データ変換

#### Storybookが適切なケース
- UIの状態パターン
- インタラクティブな動作
- レスポンシブデザイン
- コンポーネントの組み合わせ

#### E2Eテストが必要なケース
- ユーザーフロー全体
- 複数画面にまたがる操作
- 実際のAPI連携（最小限）

### 効率的なテスト実装のヒント

1. **パラメタライズドテスト**: 類似のテストケースは`it.each`で統合
```typescript
it.each([
  { input: 'valid', expected: true },
  { input: '', expected: false },
  { input: null, expected: false },
])('validates input correctly ($input)', ({ input, expected }) => {
  expect(validate(input)).toBe(expected);
});
```

2. **共通セットアップの活用**: `beforeEach`で重複を削減
3. **カスタムマッチャー**: 複雑なアサーションは関数化
4. **スナップショットの適切な使用**: 大きなオブジェクトの検証に活用

### 月次レビューチェックリスト

- [ ] テストコード量とソースコード量の比率確認
- [ ] 実行時間が1分を超えるテストファイルの特定
- [ ] 重複テストパターンの検出
- [ ] 不要になったテストの削除
- [ ] テストカバレッジの偏りチェック

## 継続的改善

1. **テストレビュー**: PRレビュー時にテストの品質も確認
2. **定期的な見直し**: テストの実行時間やカバレッジを定期的に確認
3. **エラー分析**: 失敗したテストから学び、テスト改善に活用
4. **新機能対応**: 新機能追加時は必ずテストも追加
5. **オーバーテスト監視**: 月次でテストコード量を分析し、基準を超えた場合は改善

## 参考資料

- [Testing Library](https://testing-library.com/)
- [Vitest](https://vitest.dev/)
- [MSW](https://mswjs.io/)
- [Storybook](https://storybook.js.org/)
- [Playwright](https://playwright.dev/)