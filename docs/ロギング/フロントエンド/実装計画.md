# フロントエンドロガー実装計画

## 実装概要

このドキュメントは、[フロントエンドロガー設計](./フロントエンドロガー設計.md)に基づいた具体的な実装手順を定義します。段階的な実装により、既存システムへの影響を最小限に抑えながら、包括的なフロントエンドログ機能を実現します。

## 実装フェーズ

### フェーズ1: 基盤構築（優先度: 高）

#### 1.1 プロジェクト構造の準備

```bash
# 新規ディレクトリの作成
mkdir -p frontend/src/lib/logger
mkdir -p frontend/src/lib/logger/__tests__
mkdir -p frontend/src/components/ErrorBoundary
```

#### 1.2 型定義の実装

**ファイル: `frontend/src/lib/logger/types.ts`**

```typescript
/**
 * ログレベルの定義
 * debug: 詳細なデバッグ情報（開発環境のみ）
 * info: 正常な操作の記録
 * warn: 回復可能なエラー・警告
 * error: システムエラー・失敗
 */
export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

/**
 * ログメタデータの型定義
 * フロントエンドアクションに関連する追加情報を格納
 */
export interface LogMeta {
  requestId?: string;
  userId?: string;
  component?: string;
  action?: string;
  path?: string;
  duration?: number;
  data?: Record<string, any>;
  error?: Error | string;
  stack?: string;
  [key: string]: any;
}

/**
 * ログエントリの構造定義
 * 全てのログが従う統一フォーマット
 */
export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  requestId: string;
  environment: 'development' | 'production' | 'storybook';
  session: string;
  meta: LogMeta;
}

/**
 * ログ設定の型定義
 */
export interface LoggerConfig {
  environment: 'development' | 'production' | 'storybook';
  level: LogLevel;
  bufferSize: number;
  flushInterval: number;
  enableConsole: boolean;
  apiEndpoint?: string;
}

/**
 * フロントエンドロガーインターフェース
 * 全てのロガー実装が従う共通インターフェース
 */
export interface FrontendLogger {
  debug(message: string, meta?: LogMeta): void;
  info(message: string, meta?: LogMeta): void;
  warn(message: string, meta?: LogMeta): void;
  error(message: string, meta?: LogMeta): void;
  trackUserAction(action: string, meta?: LogMeta): void;
  trackPageView(path: string, meta?: LogMeta): void;
  trackApiCall(endpoint: string, method: string, meta?: LogMeta): void;
}
```

#### 1.3 設定システムの実装

**ファイル: `frontend/src/lib/logger/config.ts`**

```typescript
import { LoggerConfig, LogLevel } from './types';

/**
 * 環境変数からロガー設定を生成
 * @returns ロガー設定
 */
export const createLoggerConfig = (): LoggerConfig => {
  const isDevelopment = process.env.NODE_ENV === 'development';
  const isStorybook = process.env.STORYBOOK === 'true';
  
  if (isStorybook) {
    return {
      environment: 'storybook',
      level: 'debug',
      bufferSize: 10,
      flushInterval: 1000,
      enableConsole: true,
    };
  }

  return {
    environment: isDevelopment ? 'development' : 'production',
    level: (process.env.NEXT_PUBLIC_LOG_LEVEL as LogLevel) || (isDevelopment ? 'debug' : 'warn'),
    bufferSize: Number(process.env.NEXT_PUBLIC_LOG_BUFFER_SIZE) || (isDevelopment ? 10 : 100),
    flushInterval: Number(process.env.NEXT_PUBLIC_LOG_FLUSH_INTERVAL) || (isDevelopment ? 1000 : 10000),
    enableConsole: isDevelopment,
    apiEndpoint: process.env.NEXT_PUBLIC_LOGGER_ENDPOINT,
  };
};

/**
 * ログレベルの数値変換
 * レベル比較に使用
 */
export const getLogLevelValue = (level: LogLevel): number => {
  switch (level) {
    case 'debug': return 0;
    case 'info': return 1;
    case 'warn': return 2;
    case 'error': return 3;
    default: return 1;
  }
};

/**
 * 現在のログレベルで出力すべきかを判定
 * @param currentLevel 現在のログレベル
 * @param targetLevel 出力対象のレベル
 * @returns 出力すべきかどうか
 */
export const shouldLog = (currentLevel: LogLevel, targetLevel: LogLevel): boolean => {
  return getLogLevelValue(targetLevel) >= getLogLevelValue(currentLevel);
};
```

#### 1.4 ユーティリティ関数の実装

**ファイル: `frontend/src/lib/logger/utils.ts`**

```typescript
/**
 * requestID生成（APIロガーと共通）
 */
export function generateRequestId(): string {
  return crypto.randomUUID();
}

/**
 * セッションID生成
 */
export function generateSessionId(): string {
  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * エラーオブジェクトのシリアライズ
 */
export function serializeError(error: Error | string): { message: string; stack?: string } {
  if (typeof error === 'string') {
    return { message: error };
  }
  
  return {
    message: error.message,
    stack: error.stack,
  };
}

/**
 * パフォーマンス計測用ヘルパー
 */
export function createPerformanceMarker() {
  const startTime = performance.now();
  
  return {
    end: () => performance.now() - startTime,
    duration: () => performance.now() - startTime,
  };
}
```

### フェーズ2: コアロガーの実装（優先度: 高）

#### 2.1 ブラウザ最適化ロガー

**ファイル: `frontend/src/lib/logger/browser-logger.ts`**

```typescript
import { FrontendLogger, LogLevel, LogEntry, LogMeta, LoggerConfig } from './types';
import { generateRequestId, generateSessionId, serializeError } from './utils';
import { shouldLog } from './config';

/**
 * ブラウザ環境向けに最適化されたロガー
 * バッファリングと非同期処理によりパフォーマンスを最適化
 */
export class BrowserLogger implements FrontendLogger {
  private config: LoggerConfig;
  private buffer: LogEntry[] = [];
  private sessionId: string;
  private flushTimer: number | null = null;

  constructor(config: LoggerConfig) {
    this.config = config;
    this.sessionId = generateSessionId();
    this.setupPeriodicFlush();
    this.setupVisibilityHandler();
  }

  /**
   * DEBUGレベルのログを出力
   */
  debug(message: string, meta: LogMeta = {}): void {
    this.log('debug', message, meta);
  }

  /**
   * INFOレベルのログを出力
   */
  info(message: string, meta: LogMeta = {}): void {
    this.log('info', message, meta);
  }

  /**
   * WARNレベルのログを出力
   */
  warn(message: string, meta: LogMeta = {}): void {
    this.log('warn', message, meta);
  }

  /**
   * ERRORレベルのログを出力
   */
  error(message: string, meta: LogMeta = {}): void {
    this.log('error', message, meta);
  }

  /**
   * ユーザーアクション追跡
   */
  trackUserAction(action: string, meta: LogMeta = {}): void {
    this.log('info', `User action: ${action}`, { 
      ...meta, 
      action,
      userAction: true 
    });
  }

  /**
   * ページビュー追跡
   */
  trackPageView(path: string, meta: LogMeta = {}): void {
    this.log('info', `Page view: ${path}`, { 
      ...meta, 
      path,
      pageView: true 
    });
  }

  /**
   * APIコール追跡
   */
  trackApiCall(endpoint: string, method: string, meta: LogMeta = {}): void {
    this.log('info', `API call: ${method} ${endpoint}`, { 
      ...meta, 
      endpoint,
      method,
      apiCall: true 
    });
  }

  /**
   * 内部ログ処理メソッド
   */
  private log(level: LogLevel, message: string, meta: LogMeta): void {
    if (!shouldLog(this.config.level, level)) return;

    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      requestId: meta.requestId || generateRequestId(),
      environment: this.config.environment,
      session: this.sessionId,
      meta: {
        ...meta,
        url: typeof window !== 'undefined' ? window.location.href : undefined,
        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,
        // エラーオブジェクトの適切なシリアライズ
        ...(meta.error && { error: serializeError(meta.error) }),
      }
    };

    if (this.config.enableConsole) {
      this.logToConsole(entry);
    }

    this.buffer.push(entry);
    
    if (this.buffer.length >= this.config.bufferSize) {
      this.flushBuffer();
    }
  }

  /**
   * コンソール出力
   */
  private logToConsole(entry: LogEntry): void {
    const consoleMethod = entry.level === 'debug' ? 'debug' : 
                         entry.level === 'warn' ? 'warn' : 
                         entry.level === 'error' ? 'error' : 'log';
    
    if (this.config.environment === 'development') {
      console[consoleMethod]('[FRONTEND]', entry.message, entry.meta);
    } else {
      console[consoleMethod](`[${entry.level.toUpperCase()}] ${entry.message}`);
    }
  }

  /**
   * 定期的なフラッシュの設定
   */
  private setupPeriodicFlush(): void {
    if (typeof window !== 'undefined') {
      this.flushTimer = window.setInterval(() => {
        this.flushBuffer();
      }, this.config.flushInterval);
    }
  }

  /**
   * ページ離脱時のログフラッシュ設定
   */
  private setupVisibilityHandler(): void {
    if (typeof document !== 'undefined') {
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          this.flushBuffer();
        }
      });
      
      window.addEventListener('beforeunload', () => {
        this.flushBuffer();
      });
    }
  }

  /**
   * バッファの内容を出力
   */
  private async flushBuffer(): Promise<void> {
    if (this.buffer.length === 0) return;

    const entries = [...this.buffer];
    this.buffer = [];

    try {
      if (this.config.apiEndpoint && this.config.environment === 'production') {
        await this.sendToServer(entries);
      }
    } catch (error) {
      console.error('Failed to send logs to server:', error);
    }
  }

  /**
   * サーバーへのログ送信
   */
  private async sendToServer(entries: LogEntry[]): Promise<void> {
    if (!this.config.apiEndpoint) return;

    try {
      await fetch(this.config.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ logs: entries }),
      });
    } catch (error) {
      // ログ送信失敗時はコンソールにフォールバック
      entries.forEach(entry => this.logToConsole(entry));
    }
  }

  /**
   * リソースのクリーンアップ
   */
  destroy(): void {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    this.flushBuffer();
  }
}

/**
 * ブラウザロガーファクトリー関数
 */
export function createBrowserLogger(config?: Partial<LoggerConfig>): FrontendLogger {
  const defaultConfig: LoggerConfig = {
    environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',
    level: process.env.NODE_ENV === 'production' ? 'warn' : 'debug',
    bufferSize: 50,
    flushInterval: 5000,
    enableConsole: true,
    apiEndpoint: process.env.NEXT_PUBLIC_LOGGER_ENDPOINT,
  };

  return new BrowserLogger({ ...defaultConfig, ...config });
}
```

#### 2.2 ユニットテスト

**ファイル: `frontend/src/lib/logger/__tests__/browser-logger.test.ts`**

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { BrowserLogger } from '../browser-logger';
import { LoggerConfig } from '../types';

// モック
Object.defineProperty(global, 'crypto', {
  value: {
    randomUUID: () => 'test-uuid-123'
  }
});

Object.defineProperty(global, 'performance', {
  value: {
    now: () => Date.now()
  }
});

describe('BrowserLogger', () => {
  let logger: BrowserLogger;
  let mockConfig: LoggerConfig;

  beforeEach(() => {
    mockConfig = {
      environment: 'development',
      level: 'debug',
      bufferSize: 10,
      flushInterval: 1000,
      enableConsole: true,
    };
    
    logger = new BrowserLogger(mockConfig);
    vi.spyOn(console, 'log').mockImplementation(() => {});
    vi.spyOn(console, 'error').mockImplementation(() => {});
  });

  afterEach(() => {
    vi.restoreAllMocks();
    logger.destroy();
  });

  it('should log debug messages in development environment', () => {
    logger.debug('Test debug message', { component: 'TestComponent' });
    
    expect(console.log).toHaveBeenCalledWith(
      '[FRONTEND]',
      'Test debug message',
      expect.objectContaining({ component: 'TestComponent' })
    );
  });

  it('should track user actions with proper metadata', () => {
    logger.trackUserAction('button_click', { buttonId: 'save-btn' });
    
    expect(console.log).toHaveBeenCalledWith(
      '[FRONTEND]',
      'User action: button_click',
      expect.objectContaining({ 
        action: 'button_click',
        buttonId: 'save-btn',
        userAction: true 
      })
    );
  });

  it('should respect log level filtering', () => {
    const infoLogger = new BrowserLogger({ ...mockConfig, level: 'info' });
    
    infoLogger.debug('This should not be logged');
    expect(console.log).not.toHaveBeenCalled();
    
    infoLogger.info('This should be logged');
    expect(console.log).toHaveBeenCalledWith(
      '[FRONTEND]',
      'This should be logged',
      expect.any(Object)
    );
    
    infoLogger.destroy();
  });

  it('should track page views', () => {
    logger.trackPageView('/dashboard', { userId: 'user123' });
    
    expect(console.log).toHaveBeenCalledWith(
      '[FRONTEND]',
      'Page view: /dashboard',
      expect.objectContaining({ 
        path: '/dashboard',
        userId: 'user123',
        pageView: true 
      })
    );
  });
});
```

### フェーズ3: React統合（優先度: 高）

#### 3.1 React Context & Hooks

**ファイル: `frontend/src/lib/logger/context.tsx`**

```typescript
'use client';

import { createContext, useContext, useCallback, useRef, ReactNode } from 'react';
import { FrontendLogger, LogMeta } from './types';
import { createBrowserLogger } from './browser-logger';
import { createLoggerConfig } from './config';

const LoggerContext = createContext<FrontendLogger | null>(null);

interface LoggerProviderProps {
  children: ReactNode;
  value?: FrontendLogger;
}

export function LoggerProvider({ children, value }: LoggerProviderProps) {
  const loggerRef = useRef<FrontendLogger | null>(null);
  
  if (!loggerRef.current && !value) {
    const config = createLoggerConfig();
    loggerRef.current = createBrowserLogger(config);
  }

  const logger = value || loggerRef.current;

  return (
    <LoggerContext.Provider value={logger}>
      {children}
    </LoggerContext.Provider>
  );
}

/**
 * 基本ロガーフック
 */
export function useLogger(): FrontendLogger {
  const logger = useContext(LoggerContext);
  if (!logger) {
    throw new Error('useLogger must be used within LoggerProvider');
  }
  return logger;
}

/**
 * コンポーネント専用ロガーフック
 */
export function useComponentLogger(componentName: string) {
  const logger = useLogger();
  
  return {
    debug: useCallback((message: string, meta?: LogMeta) => {
      logger.debug(message, { ...meta, component: componentName });
    }, [logger, componentName]),
    
    info: useCallback((message: string, meta?: LogMeta) => {
      logger.info(message, { ...meta, component: componentName });
    }, [logger, componentName]),
    
    warn: useCallback((message: string, meta?: LogMeta) => {
      logger.warn(message, { ...meta, component: componentName });
    }, [logger, componentName]),
    
    error: useCallback((message: string, meta?: LogMeta) => {
      logger.error(message, { ...meta, component: componentName });
    }, [logger, componentName]),
    
    trackAction: useCallback((action: string, meta?: LogMeta) => {
      logger.trackUserAction(action, { ...meta, component: componentName });
    }, [logger, componentName]),
  };
}

/**
 * ユーザーアクション自動ログフック
 */
export function useLoggedCallback<T extends any[]>(
  callback: (...args: T) => void,
  action: string,
  deps: React.DependencyList,
  meta?: LogMeta
) {
  const logger = useLogger();
  
  return useCallback((...args: T) => {
    const startTime = performance.now();
    
    try {
      logger.trackUserAction(`${action} started`, meta);
      callback(...args);
      
      const duration = performance.now() - startTime;
      logger.trackUserAction(`${action} completed`, { ...meta, duration });
    } catch (error) {
      const duration = performance.now() - startTime;
      logger.error(`${action} failed`, { 
        ...meta, 
        duration, 
        error: error instanceof Error ? error.message : String(error) 
      });
      throw error;
    }
  }, [...deps, logger, action]);
}

/**
 * パフォーマンス計測フック
 */
export function usePerformanceLogger(componentName: string) {
  const logger = useLogger();
  
  return {
    markStart: useCallback((operation: string) => {
      const startTime = performance.now();
      return () => {
        const duration = performance.now() - startTime;
        logger.debug(`${operation} completed`, {
          component: componentName,
          operation,
          duration,
          performance: true,
        });
      };
    }, [logger, componentName]),
  };
}
```

#### 3.2 エラーバウンダリ強化

**ファイル: `frontend/src/components/ErrorBoundary/ErrorBoundary.tsx`**

```typescript
'use client';

import React, { ErrorInfo, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({ errorInfo });
    
    // カスタムエラーハンドラー実行
    this.props.onError?.(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="min-h-screen flex items-center justify-center">
          <div className="text-center p-8">
            <h2 className="text-xl font-semibold text-gray-900 mb-4">
              エラーが発生しました
            </h2>
            <p className="text-gray-600 mb-4">
              申し訳ございません。予期しないエラーが発生しました。
            </p>
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              ページを再読み込み
            </button>
            {process.env.NODE_ENV === 'development' && (
              <details className="mt-4 text-left">
                <summary className="cursor-pointer text-sm text-gray-500">
                  詳細を表示
                </summary>
                <pre className="mt-2 text-xs text-red-600 bg-red-50 p-2 rounded overflow-auto">
                  {this.state.error?.stack}
                </pre>
              </details>
            )}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

/**
 * HOC版エラーバウンダリ
 */
export function withErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  errorFallback?: ReactNode
) {
  return function WrappedComponent(props: P) {
    return (
      <ErrorBoundary fallback={errorFallback}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
}
```

**ファイル: `frontend/src/components/ErrorBoundary/LoggingErrorBoundary.tsx`**

```typescript
'use client';

import React, { ErrorInfo, ReactNode } from 'react';
import { ErrorBoundary } from './ErrorBoundary';
import { useLogger } from '../../lib/logger/context';

interface LoggingErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

export function LoggingErrorBoundary({ children, fallback }: LoggingErrorBoundaryProps) {
  const logger = useLogger();

  const handleError = (error: Error, errorInfo: ErrorInfo) => {
    logger.error('React Error Boundary caught error', {
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      errorBoundary: true,
    });
  };

  return (
    <ErrorBoundary fallback={fallback} onError={handleError}>
      {children}
    </ErrorBoundary>
  );
}
```

#### 3.3 React Hook テスト

**ファイル: `frontend/src/lib/logger/__tests__/hooks.test.tsx`**

```typescript
import { renderHook, act } from '@testing-library/react';
import { vi } from 'vitest';
import { useComponentLogger, useLoggedCallback, LoggerProvider } from '../context';
import { createBrowserLogger } from '../browser-logger';

const mockLogger = createBrowserLogger({
  environment: 'development',
  level: 'debug',
  bufferSize: 5,
  flushInterval: 100,
  enableConsole: true,
});

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <LoggerProvider value={mockLogger}>{children}</LoggerProvider>
);

describe('Logger Hooks', () => {
  beforeEach(() => {
    vi.spyOn(console, 'log').mockImplementation(() => {});
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('useComponentLogger', () => {
    it('should include component name in logs', () => {
      const { result } = renderHook(
        () => useComponentLogger('TestComponent'),
        { wrapper }
      );

      act(() => {
        result.current.info('Test message');
      });

      expect(console.log).toHaveBeenCalledWith(
        '[FRONTEND]',
        'Test message',
        expect.objectContaining({ component: 'TestComponent' })
      );
    });

    it('should track actions with component context', () => {
      const { result } = renderHook(
        () => useComponentLogger('TestComponent'),
        { wrapper }
      );

      act(() => {
        result.current.trackAction('button_click', { buttonId: 'test' });
      });

      expect(console.log).toHaveBeenCalledWith(
        '[FRONTEND]',
        'User action: button_click',
        expect.objectContaining({ 
          component: 'TestComponent',
          action: 'button_click',
          buttonId: 'test'
        })
      );
    });
  });

  describe('useLoggedCallback', () => {
    it('should log callback execution', () => {
      const mockCallback = vi.fn();
      
      const { result } = renderHook(
        () => useLoggedCallback(mockCallback, 'test_action', []),
        { wrapper }
      );

      act(() => {
        result.current();
      });

      expect(mockCallback).toHaveBeenCalled();
      expect(console.log).toHaveBeenCalledWith(
        '[FRONTEND]',
        'User action: test_action started',
        expect.any(Object)
      );
      expect(console.log).toHaveBeenCalledWith(
        '[FRONTEND]',
        'User action: test_action completed',
        expect.objectContaining({ duration: expect.any(Number) })
      );
    });
  });
});
```

### フェーズ4: 統合とツール連携（優先度: 中）

#### 4.1 Next.js統合

**ファイル: `frontend/src/app/layout.tsx` の更新**

```typescript
import { LoggerProvider } from '../lib/logger/context';
import { LoggingErrorBoundary } from '../components/ErrorBoundary/LoggingErrorBoundary';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ja">
      <body>
        <LoggerProvider>
          <LoggingErrorBoundary>
            {children}
          </LoggingErrorBoundary>
        </LoggerProvider>
      </body>
    </html>
  );
}
```

**ファイル: `frontend/src/middleware.ts` の更新**

```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const requestId = request.headers.get('X-Request-ID') || crypto.randomUUID();
  
  // レスポンスヘッダーにrequestIdを追加
  const response = NextResponse.next();
  response.headers.set('X-Request-ID', requestId);
  
  return response;
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};
```

#### 4.2 API統合とrequestId相関

**ファイル: `frontend/src/lib/api/client.ts` の拡張**

```typescript
import { useLogger } from '../logger/context';
import { generateRequestId } from '../logger/utils';

/**
 * 既存APIクライアントにログ機能を追加
 */
export function enhanceApiClientWithLogging(apiClient: any) {
  // リクエストインターセプター
  apiClient.interceptors.request.use((config: any) => {
    const requestId = generateRequestId();
    
    // requestIdをヘッダーに追加
    config.headers['X-Request-ID'] = requestId;
    
    // メタデータに開始時刻を記録
    config.metadata = { requestId, startTime: performance.now() };
    return config;
  });

  // レスポンスインターセプター（成功）
  apiClient.interceptors.response.use(
    (response: any) => {
      const { requestId, startTime } = response.config.metadata;
      const duration = performance.now() - startTime;

      // 成功時のログは既存のlogApiError関数で処理
      return response;
    },
    (error: any) => {
      const { requestId, startTime } = error.config?.metadata || {};
      const duration = startTime ? performance.now() - startTime : undefined;

      // エラーメタデータにrequestIdを追加
      if (error.meta) {
        error.meta.requestId = requestId;
        error.meta.duration = duration;
      }

      return Promise.reject(error);
    }
  );

  return apiClient;
}

/**
 * React Hook for API logging
 */
export function useApiLogger() {
  const logger = useLogger();

  return {
    logApiCall: (endpoint: string, method: string, meta?: any) => {
      logger.trackApiCall(endpoint, method, meta);
    },
    logApiSuccess: (endpoint: string, status: number, meta?: any) => {
      logger.info(`API Success: ${endpoint}`, { ...meta, status, apiSuccess: true });
    },
    logApiError: (endpoint: string, error: any, meta?: any) => {
      logger.error(`API Error: ${endpoint}`, { ...meta, error, apiError: true });
    },
  };
}
```

#### 4.3 Storybook統合

**ファイル: `.storybook/preview.tsx` の更新**

```typescript
import type { Preview } from '@storybook/react';
import { LoggerProvider } from '../frontend/src/lib/logger/context';
import { createBrowserLogger } from '../frontend/src/lib/logger/browser-logger';

// Storybook専用ロガー設定
const storybookLogger = createBrowserLogger({
  environment: 'storybook',
  level: 'debug',
  enableConsole: true,
  bufferSize: 10,
  flushInterval: 1000,
});

const preview: Preview = {
  decorators: [
    (Story) => (
      <LoggerProvider value={storybookLogger}>
        <Story />
      </LoggerProvider>
    ),
  ],
  parameters: {
    actions: { argTypesRegex: '^on[A-Z].*' },
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/,
      },
    },
    // ログ機能の設定
    logger: {
      onAction: (action: string, args: any[]) => {
        storybookLogger.trackUserAction(`storybook:${action}`, { args });
      },
    },
  },
};

export default preview;
```

**ファイル: `.storybook/addon-logger.ts` (オプション)**

```typescript
import { addons, types } from '@storybook/manager-api';
import { ADDON_ID, PANEL_ID } from './constants';

addons.register(ADDON_ID, () => {
  addons.add(PANEL_ID, {
    type: types.PANEL,
    title: 'Logger',
    render: ({ active, key }) => {
      // ログパネルのUI実装
      return null;
    },
  });
});
```

### フェーズ5: 環境設定と最適化（優先度: 低）

#### 5.1 環境変数の設定

**ファイル: `.env.example` の更新**

```bash
# フロントエンドログ設定
NEXT_PUBLIC_LOGGER_ENDPOINT=https://api.saifuu.com/frontend-logs
NEXT_PUBLIC_LOG_LEVEL=debug
NEXT_PUBLIC_LOG_BUFFER_SIZE=10
NEXT_PUBLIC_LOG_FLUSH_INTERVAL=1000

# Storybook用
STORYBOOK=false
```

**ファイル: `.env.production`**

```bash
# 本番環境用フロントエンドログ設定
NEXT_PUBLIC_LOGGER_ENDPOINT=https://api.saifuu.com/frontend-logs
NEXT_PUBLIC_LOG_LEVEL=warn
NEXT_PUBLIC_LOG_BUFFER_SIZE=100
NEXT_PUBLIC_LOG_FLUSH_INTERVAL=10000
```

#### 5.2 package.jsonスクリプトの追加

```json
{
  "scripts": {
    "test:logger": "vitest run src/lib/logger",
    "test:logger:watch": "vitest src/lib/logger",
    "logs:debug": "NEXT_PUBLIC_LOG_LEVEL=debug npm run dev",
    "storybook:logger": "STORYBOOK=true npm run storybook"
  }
}
```

#### 5.3 TypeScript設定の調整

**ファイル: `tsconfig.json` の更新**

```json
{
  "compilerOptions": {
    // 既存設定...
    "paths": {
      "@/*": ["./src/*"],
      "@/logger": ["./src/lib/logger"],
      "@/components": ["./src/components/*"]
    }
  }
}
```

## 実装スケジュール

### 週1: 基盤構築
- [ ] プロジェクト構造の準備
- [ ] 型定義の実装
- [ ] 設定システムの実装
- [ ] ユーティリティ関数の実装

### 週2: コアロガーの実装
- [ ] BrowserLoggerクラスの実装
- [ ] ロガーファクトリーの実装
- [ ] ユニットテストの作成

### 週3: React統合
- [ ] LoggerContext & Providerの実装
- [ ] React Hooks実装
- [ ] エラーバウンダリ強化
- [ ] React Hook テストの作成

### 週4: 統合とツール連携
- [ ] Next.js統合（レイアウト、ミドルウェア）
- [ ] API統合とrequestId相関
- [ ] Storybook統合
- [ ] 環境設定の調整

## 品質チェックリスト

### 実装品質
- [ ] 型安全性の確保
- [ ] エラーハンドリングの網羅
- [ ] パフォーマンスの最適化
- [ ] ブラウザ互換性の確認

### テスト品質
- [ ] ユニットテストカバレッジ 80%以上
- [ ] React Hookテストの実装
- [ ] エラーケースのテスト
- [ ] Storybookでのコンポーネントテスト

### 運用品質
- [ ] ログの可読性
- [ ] 開発・本番環境の分離
- [ ] ドキュメントの整備
- [ ] 運用手順の明確化

## 注意事項

### 1. 既存コードへの影響
- 既存のコンポーネント動作を変更しない
- 段階的な導入でリスクを最小化
- ロールバック計画の準備

### 2. パフォーマンス
- バンドルサイズへの影響を最小限に
- ブラウザメモリ使用量の最適化
- レンダリングパフォーマンスへの影響回避

### 3. 保守性
- 明確なコードコメント
- 適切なエラーメッセージ
- 変更しやすい設計

### 4. プライバシー
- 個人用ツールのため簡素化
- 必要最小限のデータログ
- ローカルでの完結

この実装計画に従って、段階的にフロントエンドロガーを導入することで、Saifuuアプリケーションの開発・運用効率とユーザーエクスペリエンスを大幅に向上させることができます。