# フロントエンドロガー テスト戦略

## 概要

フロントエンドロガーシステムの包括的テスト戦略。80%以上のカバレッジを目標とし、ブラウザ固有の機能、パフォーマンス、エラーハンドリングを網羅的にテストする。

## 1. テスト戦略概要

### 1.1 テストピラミッド構造

```
E2Eテスト (Playwright)          # ログ送信の統合フロー
    ↑
ユニットテスト (Vitest)          # ロガー本体・ユーティリティ
```

### 1.2 テスト要件

- **カバレッジ**: 80%以上必須
- **テストフレームワーク**: Vitest（ユニットテスト）
- **ブラウザAPI**: 適切なモックを使用
- **パフォーマンス**: バッファリング・メモリ使用量を測定
- **エラーハンドリング**: 例外処理を徹底的にテスト

### 1.3 テスト対象ファイル

- `types.ts` - 型定義
- `config.ts` - 環境設定
- `browser-logger.ts` - メインロガークラス

## 2. ファイル別カバレッジ計画

### 2.1 types.ts テスト計画

#### 対象機能
- ログレベル型定義
- ログメッセージ型定義
- 設定オブジェクト型定義
- バッファ型定義
- セッション型定義

#### テストケース
```typescript
describe('Logger Types', () => {
  describe('LogLevel', () => {
    // ログレベルの型安全性テスト
    it('should accept valid log levels', () => {
      const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];
      expect(levels).toBeDefined();
    });
  });

  describe('LogMessage', () => {
    // ログメッセージ構造のテスト
    it('should validate log message structure', () => {
      const message: LogMessage = {
        level: 'info',
        message: 'test',
        timestamp: new Date(),
        context: { userId: '123' }
      };
      expect(message).toBeDefined();
    });
  });

  describe('LoggerConfig', () => {
    // 設定オブジェクトのテスト
    it('should validate logger configuration', () => {
      const config: LoggerConfig = {
        level: 'info',
        bufferSize: 100,
        flushInterval: 5000,
        endpoint: '/api/logs'
      };
      expect(config).toBeDefined();
    });
  });
});
```

#### カバレッジ目標
- **型定義**: 100%（型エラーの検出）
- **バリデーション**: 90%（境界値・不正値テスト）

### 2.2 config.ts テスト計画

#### 対象機能
- 環境別設定の読み込み
- デフォルト設定の適用
- 設定値の検証
- 動的設定の更新

#### テストケース
```typescript
describe('Logger Config', () => {
  describe('Environment Configuration', () => {
    it('should load development config', () => {
      process.env.NODE_ENV = 'development';
      const config = getLoggerConfig();
      expect(config.level).toBe('debug');
      expect(config.bufferSize).toBe(50);
    });

    it('should load production config', () => {
      process.env.NODE_ENV = 'production';
      const config = getLoggerConfig();
      expect(config.level).toBe('error');
      expect(config.bufferSize).toBe(200);
    });

    it('should load test config', () => {
      process.env.NODE_ENV = 'test';
      const config = getLoggerConfig();
      expect(config.level).toBe('silent');
      expect(config.endpoint).toBe('/api/test-logs');
    });
  });

  describe('Default Configuration', () => {
    it('should apply default values for missing config', () => {
      const partialConfig = { level: 'info' };
      const config = mergeWithDefaults(partialConfig);
      expect(config.bufferSize).toBe(100); // デフォルト値
      expect(config.flushInterval).toBe(5000); // デフォルト値
    });
  });

  describe('Configuration Validation', () => {
    it('should validate buffer size limits', () => {
      expect(() => validateConfig({ bufferSize: 0 })).toThrow();
      expect(() => validateConfig({ bufferSize: 1001 })).toThrow();
      expect(() => validateConfig({ bufferSize: 100 })).not.toThrow();
    });

    it('should validate flush interval', () => {
      expect(() => validateConfig({ flushInterval: 0 })).toThrow();
      expect(() => validateConfig({ flushInterval: 1000 })).not.toThrow();
    });
  });

  describe('Dynamic Configuration', () => {
    it('should update configuration at runtime', () => {
      const logger = new BrowserLogger();
      logger.updateConfig({ level: 'debug' });
      expect(logger.getConfig().level).toBe('debug');
    });
  });
});
```

#### カバレッジ目標
- **環境設定**: 100%（全環境のテスト）
- **バリデーション**: 95%（境界値・エラーケース）
- **動的更新**: 90%（ランタイム変更のテスト）

### 2.3 browser-logger.ts テスト計画

#### 対象機能
- ログレベル別メッセージ処理
- バッファリング機能
- 自動フラッシュ機能
- ブラウザイベント処理
- セッション管理
- エラーハンドリング

#### テストケース
```typescript
describe('BrowserLogger', () => {
  describe('Log Level Processing', () => {
    it('should log debug messages when level is debug', () => {
      const logger = new BrowserLogger({ level: 'debug' });
      const consoleSpy = vi.spyOn(console, 'debug');
      
      logger.debug('test message');
      expect(consoleSpy).toHaveBeenCalledWith('test message');
    });

    it('should not log debug messages when level is info', () => {
      const logger = new BrowserLogger({ level: 'info' });
      const consoleSpy = vi.spyOn(console, 'debug');
      
      logger.debug('test message');
      expect(consoleSpy).not.toHaveBeenCalled();
    });

    it('should log error messages regardless of level', () => {
      const logger = new BrowserLogger({ level: 'silent' });
      const consoleSpy = vi.spyOn(console, 'error');
      
      logger.error('error message');
      expect(consoleSpy).toHaveBeenCalledWith('error message');
    });
  });

  describe('Buffer Management', () => {
    it('should buffer messages up to buffer size', () => {
      const logger = new BrowserLogger({ bufferSize: 3 });
      
      logger.info('message 1');
      logger.info('message 2');
      logger.info('message 3');
      
      expect(logger.getBuffer()).toHaveLength(3);
    });

    it('should flush buffer when size limit is reached', () => {
      const logger = new BrowserLogger({ bufferSize: 2 });
      const flushSpy = vi.spyOn(logger, 'flush');
      
      logger.info('message 1');
      logger.info('message 2');
      logger.info('message 3'); // Should trigger flush
      
      expect(flushSpy).toHaveBeenCalled();
    });

    it('should preserve buffer order', () => {
      const logger = new BrowserLogger({ bufferSize: 5 });
      
      logger.info('first');
      logger.warn('second');
      logger.error('third');
      
      const buffer = logger.getBuffer();
      expect(buffer[0].message).toBe('first');
      expect(buffer[1].message).toBe('second');
      expect(buffer[2].message).toBe('third');
    });
  });

  describe('Auto Flush', () => {
    it('should auto flush after interval', async () => {
      const logger = new BrowserLogger({ flushInterval: 100 });
      const flushSpy = vi.spyOn(logger, 'flush');
      
      logger.info('test message');
      
      await vi.advanceTimersByTime(100);
      expect(flushSpy).toHaveBeenCalled();
    });

    it('should cancel auto flush on manual flush', async () => {
      const logger = new BrowserLogger({ flushInterval: 100 });
      const flushSpy = vi.spyOn(logger, 'flush');
      
      logger.info('test message');
      logger.flush(); // Manual flush
      
      await vi.advanceTimersByTime(100);
      expect(flushSpy).toHaveBeenCalledTimes(1); // Only manual flush
    });
  });

  describe('Browser Events', () => {
    it('should flush on page unload', () => {
      const logger = new BrowserLogger();
      const flushSpy = vi.spyOn(logger, 'flush');
      
      // Simulate page unload
      window.dispatchEvent(new Event('beforeunload'));
      
      expect(flushSpy).toHaveBeenCalled();
    });

    it('should flush on page visibility change', () => {
      const logger = new BrowserLogger();
      const flushSpy = vi.spyOn(logger, 'flush');
      
      // Simulate tab becoming hidden
      Object.defineProperty(document, 'visibilityState', {
        value: 'hidden',
        configurable: true
      });
      document.dispatchEvent(new Event('visibilitychange'));
      
      expect(flushSpy).toHaveBeenCalled();
    });
  });

  describe('Session Management', () => {
    it('should generate unique session ID', () => {
      const logger1 = new BrowserLogger();
      const logger2 = new BrowserLogger();
      
      expect(logger1.getSessionId()).not.toBe(logger2.getSessionId());
    });

    it('should persist session across page loads', () => {
      const logger = new BrowserLogger();
      const sessionId = logger.getSessionId();
      
      // Simulate page reload
      const newLogger = new BrowserLogger();
      expect(newLogger.getSessionId()).toBe(sessionId);
    });
  });

  describe('Error Handling', () => {
    it('should handle network errors gracefully', async () => {
      const logger = new BrowserLogger();
      
      // Mock fetch to throw network error
      global.fetch = vi.fn().mockRejectedValue(new Error('Network error'));
      
      await expect(logger.flush()).not.toThrow();
    });

    it('should retry failed requests', async () => {
      const logger = new BrowserLogger({ maxRetries: 3 });
      const fetchSpy = vi.fn()
        .mockRejectedValueOnce(new Error('Network error'))
        .mockRejectedValueOnce(new Error('Network error'))
        .mockResolvedValueOnce(new Response('OK'));
      
      global.fetch = fetchSpy;
      
      await logger.flush();
      expect(fetchSpy).toHaveBeenCalledTimes(3);
    });

    it('should handle JSON serialization errors', () => {
      const logger = new BrowserLogger();
      
      // Create circular reference
      const circular: any = {};
      circular.self = circular;
      
      expect(() => logger.info('test', circular)).not.toThrow();
    });
  });
});
```

#### カバレッジ目標
- **ログレベル処理**: 100%（全レベルのテスト）
- **バッファリング**: 95%（境界値・フラッシュ処理）
- **ブラウザイベント**: 90%（イベント処理）
- **エラーハンドリング**: 85%（例外処理）
- **セッション管理**: 80%（ID生成・永続化）

## 3. ブラウザAPIモック戦略

### 3.1 モック対象API

#### Window/Document API
```typescript
// vitest.setup.ts
import { vi } from 'vitest';

// Window API
Object.defineProperty(window, 'addEventListener', {
  value: vi.fn(),
  configurable: true
});

Object.defineProperty(window, 'removeEventListener', {
  value: vi.fn(),
  configurable: true
});

// Document API
Object.defineProperty(document, 'addEventListener', {
  value: vi.fn(),
  configurable: true
});

Object.defineProperty(document, 'visibilityState', {
  value: 'visible',
  configurable: true,
  writable: true
});
```

#### Fetch API
```typescript
// __tests__/mocks/fetch.ts
export const mockFetch = (response: any = {}, options: any = {}) => {
  return vi.fn().mockResolvedValue({
    ok: true,
    status: 200,
    json: () => Promise.resolve(response),
    text: () => Promise.resolve(JSON.stringify(response)),
    ...options
  });
};

// ネットワークエラーのモック
export const mockNetworkError = () => {
  return vi.fn().mockRejectedValue(new Error('Network error'));
};

// タイムアウトエラーのモック
export const mockTimeoutError = () => {
  return vi.fn().mockRejectedValue(new Error('Request timeout'));
};
```

#### LocalStorage API
```typescript
// __tests__/mocks/localStorage.ts
export const mockLocalStorage = () => {
  const store: Record<string, string> = {};
  
  return {
    getItem: vi.fn((key: string) => store[key] || null),
    setItem: vi.fn((key: string, value: string) => {
      store[key] = value;
    }),
    removeItem: vi.fn((key: string) => {
      delete store[key];
    }),
    clear: vi.fn(() => {
      Object.keys(store).forEach(key => delete store[key]);
    })
  };
};
```

#### Performance API
```typescript
// __tests__/mocks/performance.ts
export const mockPerformance = () => {
  return {
    now: vi.fn(() => Date.now()),
    mark: vi.fn(),
    measure: vi.fn(),
    getEntriesByName: vi.fn(() => []),
    getEntriesByType: vi.fn(() => [])
  };
};
```

### 3.2 モック設定

#### テストセットアップ
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/__tests__/setup.ts'],
    globals: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  }
});
```

#### グローバルセットアップ
```typescript
// src/__tests__/setup.ts
import { beforeEach, vi } from 'vitest';
import { mockLocalStorage, mockFetch, mockPerformance } from './mocks';

beforeEach(() => {
  // DOM環境のリセット
  document.body.innerHTML = '';
  
  // API モックの設定
  global.fetch = mockFetch();
  global.localStorage = mockLocalStorage();
  global.performance = mockPerformance();
  
  // タイマーのモック
  vi.useFakeTimers();
});

afterEach(() => {
  vi.clearAllMocks();
  vi.useRealTimers();
});
```

## 4. テストデータ組織化

### 4.1 ディレクトリ構造

```
src/
├── lib/
│   ├── logger/
│   │   ├── __tests__/
│   │   │   ├── fixtures/
│   │   │   │   ├── log-messages.ts
│   │   │   │   ├── configurations.ts
│   │   │   │   └── browser-events.ts
│   │   │   ├── mocks/
│   │   │   │   ├── fetch.ts
│   │   │   │   ├── localStorage.ts
│   │   │   │   └── performance.ts
│   │   │   ├── utils/
│   │   │   │   ├── test-helpers.ts
│   │   │   │   └── assertions.ts
│   │   │   ├── browser-logger.test.ts
│   │   │   ├── config.test.ts
│   │   │   └── types.test.ts
│   │   ├── types.ts
│   │   ├── config.ts
│   │   └── browser-logger.ts
│   └── ...
```

### 4.2 テストフィクスチャ

#### ログメッセージフィクスチャ
```typescript
// __tests__/fixtures/log-messages.ts
export const logMessages = {
  debug: {
    level: 'debug' as const,
    message: 'Debug message',
    timestamp: new Date('2024-01-01T00:00:00Z'),
    context: { userId: 'test-user' }
  },
  info: {
    level: 'info' as const,
    message: 'Info message',
    timestamp: new Date('2024-01-01T00:00:01Z'),
    context: { action: 'user-login' }
  },
  warn: {
    level: 'warn' as const,
    message: 'Warning message',
    timestamp: new Date('2024-01-01T00:00:02Z'),
    context: { warning: 'deprecated-api' }
  },
  error: {
    level: 'error' as const,
    message: 'Error message',
    timestamp: new Date('2024-01-01T00:00:03Z'),
    context: { error: 'network-timeout' }
  }
};

export const createLogMessage = (overrides: Partial<LogMessage> = {}): LogMessage => ({
  ...logMessages.info,
  ...overrides
});
```

#### 設定フィクスチャ
```typescript
// __tests__/fixtures/configurations.ts
export const configurations = {
  development: {
    level: 'debug' as const,
    bufferSize: 50,
    flushInterval: 1000,
    endpoint: '/api/dev-logs',
    maxRetries: 3
  },
  production: {
    level: 'error' as const,
    bufferSize: 200,
    flushInterval: 5000,
    endpoint: '/api/logs',
    maxRetries: 1
  },
  test: {
    level: 'silent' as const,
    bufferSize: 10,
    flushInterval: 100,
    endpoint: '/api/test-logs',
    maxRetries: 0
  }
};

export const createConfig = (overrides: Partial<LoggerConfig> = {}): LoggerConfig => ({
  ...configurations.development,
  ...overrides
});
```

### 4.3 テストヘルパー

#### テストユーティリティ
```typescript
// __tests__/utils/test-helpers.ts
export const createMockLogger = (config: Partial<LoggerConfig> = {}) => {
  const mockConfig = createConfig(config);
  return new BrowserLogger(mockConfig);
};

export const waitForFlush = async (logger: BrowserLogger, timeout = 1000) => {
  await new Promise(resolve => setTimeout(resolve, timeout));
  return logger.flush();
};

export const triggerBrowserEvent = (eventType: string, data?: any) => {
  const event = new Event(eventType);
  if (data) {
    Object.assign(event, data);
  }
  window.dispatchEvent(event);
};

export const fillBuffer = (logger: BrowserLogger, count: number) => {
  for (let i = 0; i < count; i++) {
    logger.info(`Message ${i + 1}`);
  }
};
```

#### カスタムアサーション
```typescript
// __tests__/utils/assertions.ts
export const expectLogMessage = (actual: LogMessage, expected: Partial<LogMessage>) => {
  expect(actual.level).toBe(expected.level);
  expect(actual.message).toBe(expected.message);
  if (expected.context) {
    expect(actual.context).toEqual(expected.context);
  }
};

export const expectBufferSize = (logger: BrowserLogger, size: number) => {
  expect(logger.getBuffer()).toHaveLength(size);
};

export const expectFlushCalled = (fetchSpy: any, times = 1) => {
  expect(fetchSpy).toHaveBeenCalledTimes(times);
};
```

## 5. パフォーマンステスト戦略

### 5.1 測定対象

#### メモリ使用量
```typescript
describe('Memory Performance', () => {
  it('should not exceed memory limit with large buffer', () => {
    const logger = new BrowserLogger({ bufferSize: 1000 });
    
    // 大量のログメッセージを生成
    for (let i = 0; i < 1000; i++) {
      logger.info(`Message ${i}`, { data: new Array(100).fill('x') });
    }
    
    // メモリ使用量を測定（実際の実装では performance.measureUserAgentSpecificMemory を使用）
    const memoryUsage = performance.memory?.usedJSHeapSize || 0;
    expect(memoryUsage).toBeLessThan(50 * 1024 * 1024); // 50MB以下
  });

  it('should release memory after flush', async () => {
    const logger = new BrowserLogger({ bufferSize: 100 });
    
    fillBuffer(logger, 100);
    const beforeFlush = performance.memory?.usedJSHeapSize || 0;
    
    await logger.flush();
    const afterFlush = performance.memory?.usedJSHeapSize || 0;
    
    expect(afterFlush).toBeLessThan(beforeFlush);
  });
});
```

#### 処理時間
```typescript
describe('Processing Performance', () => {
  it('should log messages within acceptable time', () => {
    const logger = new BrowserLogger();
    
    const start = performance.now();
    for (let i = 0; i < 1000; i++) {
      logger.info(`Message ${i}`);
    }
    const end = performance.now();
    
    expect(end - start).toBeLessThan(100); // 100ms以下
  });

  it('should flush buffer within acceptable time', async () => {
    const logger = new BrowserLogger({ bufferSize: 100 });
    fillBuffer(logger, 100);
    
    const start = performance.now();
    await logger.flush();
    const end = performance.now();
    
    expect(end - start).toBeLessThan(500); // 500ms以下
  });
});
```

#### スループット
```typescript
describe('Throughput Performance', () => {
  it('should handle high-frequency logging', () => {
    const logger = new BrowserLogger();
    const messagesPerSecond = 1000;
    
    const start = Date.now();
    for (let i = 0; i < messagesPerSecond; i++) {
      logger.info(`High frequency message ${i}`);
    }
    const end = Date.now();
    
    expect(end - start).toBeLessThan(1000); // 1秒以内
  });
});
```

### 5.2 パフォーマンス測定ツール

#### カスタムパフォーマンステスト
```typescript
// __tests__/utils/performance.ts
export class PerformanceTestHelper {
  private marks: Map<string, number> = new Map();
  
  start(name: string) {
    this.marks.set(name, performance.now());
  }
  
  end(name: string): number {
    const startTime = this.marks.get(name);
    if (!startTime) throw new Error(`Mark ${name} not found`);
    
    const endTime = performance.now();
    const duration = endTime - startTime;
    this.marks.delete(name);
    
    return duration;
  }
  
  measure(name: string, fn: () => void): number {
    this.start(name);
    fn();
    return this.end(name);
  }
  
  async measureAsync(name: string, fn: () => Promise<void>): Promise<number> {
    this.start(name);
    await fn();
    return this.end(name);
  }
}
```

## 6. 統合テストポイント

### 6.1 API統合テスト

#### ログ送信API
```typescript
describe('API Integration', () => {
  it('should send logs to correct endpoint', async () => {
    const logger = new BrowserLogger({ endpoint: '/api/logs' });
    const fetchSpy = vi.spyOn(global, 'fetch').mockResolvedValue(new Response('OK'));
    
    logger.info('Test message');
    await logger.flush();
    
    expect(fetchSpy).toHaveBeenCalledWith('/api/logs', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: expect.stringContaining('Test message')
    });
  });

  it('should handle API errors gracefully', async () => {
    const logger = new BrowserLogger();
    vi.spyOn(global, 'fetch').mockRejectedValue(new Error('API Error'));
    
    await expect(logger.flush()).not.toThrow();
  });
});
```

### 6.2 React統合テスト

#### Hookテスト
```typescript
// hooks/useLogger.test.ts
import { renderHook, act } from '@testing-library/react';
import { useLogger } from './useLogger';

describe('useLogger Hook', () => {
  it('should provide logger instance', () => {
    const { result } = renderHook(() => useLogger());
    
    expect(result.current).toBeDefined();
    expect(typeof result.current.info).toBe('function');
  });

  it('should log messages through hook', () => {
    const { result } = renderHook(() => useLogger());
    const consoleSpy = vi.spyOn(console, 'info');
    
    act(() => {
      result.current.info('Hook test message');
    });
    
    expect(consoleSpy).toHaveBeenCalledWith('Hook test message');
  });
});
```

### 6.3 Next.js統合テスト

#### SSR対応テスト
```typescript
describe('SSR Integration', () => {
  it('should not crash during server-side rendering', () => {
    // window オブジェクトが存在しない環境をシミュレート
    const originalWindow = global.window;
    delete (global as any).window;
    
    expect(() => {
      const logger = new BrowserLogger();
      logger.info('SSR test');
    }).not.toThrow();
    
    global.window = originalWindow;
  });
});
```

## 7. テスト実行とカバレッジ

### 7.1 テストスクリプト

#### package.json設定
```json
{
  "scripts": {
    "test:logger": "vitest run src/lib/logger",
    "test:logger:watch": "vitest src/lib/logger",
    "test:logger:coverage": "vitest run src/lib/logger --coverage",
    "test:logger:ui": "vitest --ui src/lib/logger"
  }
}
```

### 7.2 カバレッジレポート

#### 目標カバレッジ
- **総合カバレッジ**: 80%以上
- **関数カバレッジ**: 85%以上
- **分岐カバレッジ**: 75%以上
- **行カバレッジ**: 80%以上

#### カバレッジ除外
```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    coverage: {
      exclude: [
        'src/lib/logger/__tests__/**',
        'src/lib/logger/types.ts', // 型定義ファイル
        'src/lib/logger/**/*.d.ts'
      ]
    }
  }
});
```

## 8. CI/CD統合

### 8.1 GitHub Actions設定

```yaml
# .github/workflows/logger-tests.yml
name: Logger Tests

on:
  push:
    paths:
      - 'frontend/src/lib/logger/**'
  pull_request:
    paths:
      - 'frontend/src/lib/logger/**'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
      - run: npm ci
      - run: npm run test:logger:coverage
      - uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
```

### 8.2 品質ゲート

- **テスト成功率**: 100%
- **カバレッジ**: 80%以上
- **TypeScript**: エラーなし
- **Lint**: 警告なし

## 9. 継続的改善

### 9.1 メトリクス監視

- **テスト実行時間**: 30秒以内
- **カバレッジ推移**: 毎月レビュー
- **テスト失敗率**: 1%以下

### 9.2 テストメンテナンス

- **月次レビュー**: テストケースの有効性確認
- **四半期更新**: 新機能に対応したテスト追加
- **年次見直し**: テスト戦略の全体的な見直し

---

この戦略文書は、フロントエンドロガーシステムの包括的なテストを実現し、80%以上のカバレッジを確保するための指針となります。実装時は、TDD原則に従って「Red → Green → Refactor」のサイクルを繰り返し、品質の高いコードを構築してください。