# 収入・支出機能の共通化分析

## 現在の実装状況

### 1. 型定義の重複

#### 収入（income.ts）
```typescript
export interface IncomeFormData {
  amount: number;
  type: "income";  // 固定値
  description?: string;
  date: string;
  categoryId?: string;
}

export interface IncomeFormProps {
  onSubmit: (data: IncomeFormData) => void;
  onCancel: () => void;
  isSubmitting?: boolean;
  initialData?: IncomeFormData;
  categories: Category[];
  className?: string;
}

export interface IncomeListProps {
  transactions: Transaction[];
  isLoading?: boolean;
  error?: string;
  onEdit?: (transaction: Transaction) => void;
  onDelete?: (transactionId: string) => void;
  className?: string;
}
```

#### 支出（expense.ts）
```typescript
export interface ExpenseFormData {
  amount: number;
  type: TransactionType;  // "income" | "expense"
  description?: string;
  date: string;
  categoryId?: string;
}

export interface ExpenseFormProps {
  onSubmit: (data: ExpenseFormData) => void;
  onCancel: () => void;
  isSubmitting?: boolean;
  initialData?: ExpenseFormData;
  categories: Category[];
  className?: string;
}

export interface ExpenseListProps {
  transactions: Transaction[];
  isLoading?: boolean;
  error?: string;
  onEdit?: (transaction: Transaction) => void;
  onDelete?: (transactionId: string) => void;
  className?: string;
}
```

**相違点**: 
- `IncomeFormData`では`type`が固定値`"income"`
- `ExpenseFormData`では`type`が`TransactionType`（可変）
- その他のプロパティは完全に同一

### 2. カスタムフックの重複

#### useIncomes.ts と useExpenses.ts の比較

両フックは以下の点で共通：
- 状態管理（`loading`, `error`, `operationLoading`）
- CRUD操作（`create`, `update`, `delete`, `getById`）
- データ取得ロジック
- エラーハンドリング

相違点：
- エンドポイントのフィルタ（`type: "income"` vs `type: "expense"`）
- エラーメッセージの文言（「収入」vs「支出」）
- 関数名（`createIncomeMutation` vs `createExpenseMutation`）

### 3. コンポーネントの重複

#### フォームコンポーネント
- `IncomeForm.tsx` と `ExpenseForm.tsx` はほぼ同一の構造
- フィールド、バリデーション、イベントハンドリングが共通
- カラースキームの違い（緑系 vs 赤系）のみ

#### リストコンポーネント
- `IncomeList.tsx` と `ExpenseList.tsx` も同様に重複
- 表示ロジック、フィルタリング、ソートが共通

### 4. APIレベルの共通化状況

#### 既に共通化されている部分
```typescript
// transactions.ts（API service）
export async function getTransactions(query?: GetTransactionsQuery): Promise<Transaction[]>
export async function createTransaction(data: CreateTransactionRequest): Promise<Transaction>
export async function updateTransaction(id: string, data: UpdateTransactionRequest): Promise<Transaction>
export async function deleteTransaction(id: string): Promise<DeleteResponse>
```

#### バックエンドAPI（Hono）
- `/api/transactions` エンドポイントで収入・支出を統一管理
- `type`パラメータで区別（`?type=income` or `?type=expense`）

## 共通化の提案

### 1. 基本型の統一

```typescript
// types/transaction.ts（新規作成）
export interface TransactionFormData {
  amount: number;
  type: TransactionType;
  description?: string;
  date: string;
  categoryId?: string;
}

export interface TransactionFormProps {
  onSubmit: (data: TransactionFormData) => void;
  onCancel: () => void;
  isSubmitting?: boolean;
  initialData?: TransactionFormData;
  categories: Category[];
  transactionType: TransactionType;  // 追加：収入/支出を指定
  className?: string;
}

export interface TransactionListProps {
  transactions: Transaction[];
  isLoading?: boolean;
  error?: string;
  onEdit?: (transaction: Transaction) => void;
  onDelete?: (transactionId: string) => void;
  transactionType: TransactionType;  // 追加：表示タイプを指定
  className?: string;
}
```

### 2. 汎用カスタムフックの作成

```typescript
// hooks/useTransactions.ts
export function useTransactions(type: TransactionType) {
  // 共通のCRUDロジック
  // typeに基づいてフィルタリングとメッセージを切り替え
}

// 既存フックは互換性のためのラッパーに
export function useIncomes() {
  return useTransactions('income');
}

export function useExpenses() {
  return useTransactions('expense');
}
```

### 3. 共通コンポーネントの作成

```typescript
// components/transactions/TransactionForm.tsx
export const TransactionForm: FC<TransactionFormProps> = ({
  transactionType,
  ...props
}) => {
  // typeに応じたスタイリング（緑系/赤系）
  const colorScheme = transactionType === 'income' ? 'green' : 'red';
  // 共通のフォームロジック
};

// 既存コンポーネントは互換性のためのラッパーに
export const IncomeForm = (props) => (
  <TransactionForm {...props} transactionType="income" />
);
```

### 4. 共通ユーティリティの作成

```typescript
// utils/transaction.ts
export const getTransactionLabel = (type: TransactionType) => 
  type === 'income' ? '収入' : '支出';

export const getTransactionColorScheme = (type: TransactionType) => 
  type === 'income' ? 'green' : 'red';

export const getTransactionMessages = (type: TransactionType) => ({
  createSuccess: `${getTransactionLabel(type)}を登録しました`,
  createError: `${getTransactionLabel(type)}の登録に失敗しました`,
  updateSuccess: `${getTransactionLabel(type)}を更新しました`,
  updateError: `${getTransactionLabel(type)}の更新に失敗しました`,
  deleteSuccess: `${getTransactionLabel(type)}を削除しました`,
  deleteError: `${getTransactionLabel(type)}の削除に失敗しました`,
});
```

## 実装優先順位

1. **Phase 1**: 型定義の統一
   - 新しい共通型を作成
   - 既存の型定義を共通型を使用するように更新

2. **Phase 2**: カスタムフックの共通化
   - `useTransactions`フックを作成
   - 既存フックをラッパー化

3. **Phase 3**: コンポーネントの共通化
   - 共通コンポーネントを作成
   - 既存コンポーネントをラッパー化

4. **Phase 4**: テストの更新
   - 共通化に合わせてテストを更新
   - 新しい共通コンポーネントのテストを追加

## メリット

1. **コードの重複削減**: 約50%のコード削減が見込める
2. **保守性の向上**: バグ修正や機能追加が一箇所で済む
3. **一貫性の確保**: UIや動作の一貫性が保たれる
4. **拡張性**: 新しい取引タイプの追加が容易

## 注意点

1. **後方互換性**: 既存のコンポーネントを使用している箇所への影響を最小限に
2. **段階的移行**: 一度にすべてを変更せず、段階的に実施
3. **テストカバレッジ**: 共通化による影響をテストで確認
4. **パフォーマンス**: 不要な再レンダリングを避ける設計

## 次のステップ

1. この分析結果のレビューと承認
2. 実装計画の詳細化
3. Phase 1から順次実装開始