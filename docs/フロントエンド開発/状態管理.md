# 状態管理ガイド

## 概要

Saifuuでは、シンプルで保守性の高い状態管理を実現するため、React標準のフックとカスタムフックを中心とした状態管理戦略を採用しています。

## 状態の分類と管理方針

### 1. ローカル状態（Local State）
**定義**: 単一コンポーネント内でのみ使用される状態

**管理方法**: `useState`、`useReducer`

```typescript
// シンプルな状態管理
function ExpenseForm() {
  const [amount, setAmount] = useState('');
  const [category, setCategory] = useState('');
  
  // フォームの状態管理
  const [formState, dispatch] = useReducer(formReducer, initialState);
}
```

### 2. サーバー状態（Server State）
**定義**: APIから取得し、キャッシュ・同期が必要なデータ

**管理方法**: カスタムフック（React Query風の実装）

```typescript
// hooks/useExpenses.ts
export function useExpenses(filters?: ExpenseFilters) {
  const [data, setData] = useState<Expense[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setIsLoading(true);
        const expenses = await api.expenses.list(filters);
        setData(expenses);
      } catch (err) {
        setError(err as Error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchData();
  }, [filters]);
  
  const mutate = useCallback(async () => {
    // データの再取得
  }, [filters]);
  
  return { data, isLoading, error, mutate };
}
```

### 3. グローバル状態（Global State）
**定義**: 複数のコンポーネント間で共有される状態

**管理方法**: Context API（最小限の使用）

```typescript
// contexts/ThemeContext.tsx
type ThemeContextType = {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
};

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}
```

### 4. URL状態（URL State）
**定義**: URLのクエリパラメータやパスに保存される状態

**管理方法**: Next.js の `useSearchParams`、`useRouter`

```typescript
// フィルター状態をURLで管理
function ExpenseListPage() {
  const searchParams = useSearchParams();
  const router = useRouter();
  
  const currentMonth = searchParams.get('month') || getCurrentMonth();
  const category = searchParams.get('category') || 'all';
  
  const updateFilter = (key: string, value: string) => {
    const params = new URLSearchParams(searchParams);
    params.set(key, value);
    router.push(`?${params.toString()}`);
  };
  
  return (
    <ExpenseList 
      month={currentMonth}
      category={category}
      onFilterChange={updateFilter}
    />
  );
}
```

## カスタムフックパターン

### データフェッチング用フック
```typescript
// hooks/api/useApiQuery.ts
type UseApiQueryOptions<T> = {
  key: string[];
  fetcher: () => Promise<T>;
  enabled?: boolean;
  refetchInterval?: number;
};

export function useApiQuery<T>({ 
  key, 
  fetcher, 
  enabled = true,
  refetchInterval 
}: UseApiQueryOptions<T>) {
  const [data, setData] = useState<T | undefined>();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const execute = useCallback(async () => {
    if (!enabled) return;
    
    try {
      setIsLoading(true);
      setError(null);
      const result = await fetcher();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setIsLoading(false);
    }
  }, [fetcher, enabled]);
  
  useEffect(() => {
    execute();
  }, [execute]);
  
  // 自動リフェッチ
  useEffect(() => {
    if (!refetchInterval) return;
    
    const interval = setInterval(execute, refetchInterval);
    return () => clearInterval(interval);
  }, [execute, refetchInterval]);
  
  return { data, isLoading, error, refetch: execute };
}
```

### ミューテーション用フック
```typescript
// hooks/api/useApiMutation.ts
type UseApiMutationOptions<TData, TVariables> = {
  mutationFn: (variables: TVariables) => Promise<TData>;
  onSuccess?: (data: TData) => void;
  onError?: (error: Error) => void;
};

export function useApiMutation<TData, TVariables>({
  mutationFn,
  onSuccess,
  onError,
}: UseApiMutationOptions<TData, TVariables>) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const mutate = useCallback(async (variables: TVariables) => {
    try {
      setIsLoading(true);
      setError(null);
      const data = await mutationFn(variables);
      onSuccess?.(data);
      return data;
    } catch (err) {
      const error = err as Error;
      setError(error);
      onError?.(error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [mutationFn, onSuccess, onError]);
  
  return { mutate, isLoading, error };
}
```

## 状態管理のベストプラクティス

### 1. 状態の最小化
```typescript
// 悪い例：冗長な状態
function BadExample() {
  const [items, setItems] = useState([]);
  const [itemCount, setItemCount] = useState(0); // itemsから計算可能
  const [isEmpty, setIsEmpty] = useState(true);   // itemsから計算可能
}

// 良い例：必要最小限の状態
function GoodExample() {
  const [items, setItems] = useState([]);
  
  // 導出状態として計算
  const itemCount = items.length;
  const isEmpty = items.length === 0;
}
```

### 2. 状態の正規化
```typescript
// 悪い例：ネストされたデータ構造
type BadState = {
  expenses: {
    id: string;
    category: {
      id: string;
      name: string;
      expenses: Expense[]; // 循環参照
    };
  }[];
};

// 良い例：正規化されたデータ構造
type GoodState = {
  expenses: Record<string, Expense>;
  categories: Record<string, Category>;
  expenseIdsByCategory: Record<string, string[]>;
};
```

### 3. 楽観的更新（Optimistic Updates）
```typescript
function useOptimisticExpenses() {
  const [expenses, setExpenses] = useState<Expense[]>([]);
  
  const deleteExpense = async (id: string) => {
    // 楽観的に状態を更新
    const previousExpenses = expenses;
    setExpenses(prev => prev.filter(exp => exp.id !== id));
    
    try {
      await api.expenses.delete(id);
    } catch (error) {
      // エラー時は元に戻す
      setExpenses(previousExpenses);
      throw error;
    }
  };
  
  return { expenses, deleteExpense };
}
```

### 4. 状態の永続化
```typescript
// hooks/useLocalStorage.ts
export function useLocalStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error loading localStorage key "${key}":`, error);
      return initialValue;
    }
  });
  
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };
  
  return [storedValue, setValue] as const;
}
```

## 状態の同期とキャッシュ

### キャッシュ戦略
```typescript
// lib/cache.ts
class SimpleCache<T> {
  private cache = new Map<string, { data: T; timestamp: number }>();
  private ttl: number;
  
  constructor(ttl: number = 5 * 60 * 1000) { // 5分
    this.ttl = ttl;
  }
  
  set(key: string, data: T) {
    this.cache.set(key, { data, timestamp: Date.now() });
  }
  
  get(key: string): T | null {
    const cached = this.cache.get(key);
    if (!cached) return null;
    
    if (Date.now() - cached.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.data;
  }
  
  invalidate(key: string) {
    this.cache.delete(key);
  }
  
  invalidateAll() {
    this.cache.clear();
  }
}

// 使用例
const expenseCache = new SimpleCache<Expense[]>();

export function useCachedExpenses() {
  const [expenses, setExpenses] = useState<Expense[]>([]);
  
  useEffect(() => {
    const cacheKey = 'expenses-list';
    const cached = expenseCache.get(cacheKey);
    
    if (cached) {
      setExpenses(cached);
      return;
    }
    
    api.expenses.list().then(data => {
      setExpenses(data);
      expenseCache.set(cacheKey, data);
    });
  }, []);
  
  return expenses;
}
```

## エラー処理とローディング状態

### 統一されたローディング・エラー処理
```typescript
// components/common/AsyncBoundary.tsx
type AsyncBoundaryProps = {
  isLoading?: boolean;
  error?: Error | null;
  loadingFallback?: ReactNode;
  errorFallback?: (error: Error, retry: () => void) => ReactNode;
  children: ReactNode;
};

export function AsyncBoundary({
  isLoading,
  error,
  loadingFallback = <LoadingSpinner />,
  errorFallback = (error, retry) => <ErrorMessage error={error} onRetry={retry} />,
  children,
}: AsyncBoundaryProps) {
  if (isLoading) return <>{loadingFallback}</>;
  if (error) return <>{errorFallback(error, () => window.location.reload())}</>;
  return <>{children}</>;
}

// 使用例
function ExpensePage() {
  const { data, isLoading, error } = useExpenses();
  
  return (
    <AsyncBoundary isLoading={isLoading} error={error}>
      <ExpenseList expenses={data} />
    </AsyncBoundary>
  );
}
```

## デバッグとデベロッパーツール

### 状態のデバッグ
```typescript
// hooks/useDebugState.ts (開発環境のみ)
export function useDebugState<T>(initialState: T, name: string) {
  const [state, setState] = useState<T>(initialState);
  
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      console.log(`[${name}] State updated:`, state);
    }
  }, [state, name]);
  
  const setDebugState = useCallback((newState: T | ((prev: T) => T)) => {
    if (process.env.NODE_ENV === 'development') {
      console.log(`[${name}] Setting state`);
    }
    setState(newState);
  }, [name]);
  
  return [state, setDebugState] as const;
}
```

## パフォーマンス最適化

### 1. メモ化の適切な使用
```typescript
// 重い計算のメモ化
const expenseSummary = useMemo(() => {
  return expenses.reduce((acc, expense) => {
    const category = expense.category || 'その他';
    acc[category] = (acc[category] || 0) + expense.amount;
    return acc;
  }, {} as Record<string, number>);
}, [expenses]);

// コールバックのメモ化
const handleExpenseUpdate = useCallback((id: string, data: Partial<Expense>) => {
  updateExpense(id, data);
}, [updateExpense]);
```

### 2. 状態更新の最適化
```typescript
// バッチ更新
const updateMultipleExpenses = (updates: Array<{ id: string; data: Partial<Expense> }>) => {
  setExpenses(prev => {
    const newExpenses = [...prev];
    updates.forEach(({ id, data }) => {
      const index = newExpenses.findIndex(exp => exp.id === id);
      if (index !== -1) {
        newExpenses[index] = { ...newExpenses[index], ...data };
      }
    });
    return newExpenses;
  });
};
```

## まとめ

Saifuuの状態管理は、以下の原則に基づいています：

1. **シンプルさを保つ**: 複雑な状態管理ライブラリは使用せず、React標準機能を活用
2. **適材適所**: 状態の種類に応じて適切な管理方法を選択
3. **型安全性**: TypeScriptによる完全な型定義
4. **パフォーマンス**: 必要に応じた最適化のみ実施
5. **保守性**: 明確な責任分離と再利用可能なパターン