# フロントエンド パフォーマンス最適化ガイド

## 概要

Saifuuのフロントエンドパフォーマンスは、ユーザー体験の質に直結します。このガイドでは、Next.js 15とCloudflare Workers環境での最適化手法を解説します。

## パフォーマンス指標

### Core Web Vitals
目標値を設定し、継続的に監視します。

```typescript
// パフォーマンス目標値
const performanceTargets = {
  LCP: 2.5,    // Largest Contentful Paint: 2.5秒以内
  FID: 100,    // First Input Delay: 100ms以内
  CLS: 0.1,    // Cumulative Layout Shift: 0.1以内
  TTFB: 800,   // Time to First Byte: 800ms以内
};
```

### 測定方法
```typescript
// lib/performance.ts
export function measureWebVitals() {
  if (typeof window === 'undefined') return;

  import('web-vitals').then(({ getCLS, getFID, getLCP, getTTFB }) => {
    getCLS(console.log);
    getFID(console.log);
    getLCP(console.log);
    getTTFB(console.log);
  });
}
```

## レンダリング最適化

### 1. Server Components の活用
```typescript
// ✅ Good: Server Component（デフォルト）
// app/expenses/ExpenseList.tsx
async function ExpenseList() {
  const expenses = await fetchExpenses(); // サーバーサイドでデータ取得
  
  return (
    <div>
      {expenses.map(expense => (
        <ExpenseItem key={expense.id} expense={expense} />
      ))}
    </div>
  );
}

// ❌ Bad: 不要なClient Component
'use client';
function ExpenseList() {
  const [expenses, setExpenses] = useState([]);
  
  useEffect(() => {
    fetchExpenses().then(setExpenses); // クライアントサイドでデータ取得
  }, []);
}
```

### 2. Suspense と Streaming
```typescript
// app/dashboard/page.tsx
import { Suspense } from 'react';
import { ExpenseSummary, RecentTransactions, MonthlyChart } from './components';

export default function DashboardPage() {
  return (
    <div className="grid gap-6">
      {/* 各セクションを独立してストリーミング */}
      <Suspense fallback={<SummarySkeleton />}>
        <ExpenseSummary />
      </Suspense>
      
      <Suspense fallback={<ChartSkeleton />}>
        <MonthlyChart />
      </Suspense>
      
      <Suspense fallback={<TransactionsSkeleton />}>
        <RecentTransactions />
      </Suspense>
    </div>
  );
}
```

### 3. 動的インポート
```typescript
// components/features/reports/ReportGenerator.tsx
import dynamic from 'next/dynamic';

// 重いチャートライブラリを遅延読み込み
const ExpenseChart = dynamic(
  () => import('./ExpenseChart'),
  {
    loading: () => <ChartSkeleton />,
    ssr: false, // クライアントサイドのみでレンダリング
  }
);

// PDFエクスポート機能を条件付きで読み込み
const exportToPDF = async (data: ExpenseData) => {
  const { generatePDF } = await import('@/lib/pdf-generator');
  return generatePDF(data);
};
```

## データフェッチング最適化

### 1. 並列データフェッチング
```typescript
// ❌ Bad: 直列的なデータ取得
async function DashboardData() {
  const user = await fetchUser();
  const expenses = await fetchExpenses(user.id);
  const categories = await fetchCategories(user.id);
  
  return { user, expenses, categories };
}

// ✅ Good: 並列データ取得
async function DashboardData() {
  const [user, expenses, categories] = await Promise.all([
    fetchUser(),
    fetchExpenses(),
    fetchCategories(),
  ]);
  
  return { user, expenses, categories };
}
```

### 2. データのプリフェッチ
```typescript
// app/expenses/[id]/page.tsx
import { prefetchExpense } from '@/lib/api/expenses';

// リンクホバー時にデータをプリフェッチ
export function ExpenseLink({ id, children }: ExpenseLink
Props) {
  return (
    <Link
      href={`/expenses/${id}`}
      onMouseEnter={() => prefetchExpense(id)}
      onTouchStart={() => prefetchExpense(id)}
    >
      {children}
    </Link>
  );
}
```

### 3. キャッシュ戦略
```typescript
// lib/api/cache.ts
const cache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5分

export async function fetchWithCache<T>(
  key: string,
  fetcher: () => Promise<T>,
  options?: { revalidate?: number }
): Promise<T> {
  const cached = cache.get(key);
  const now = Date.now();
  
  if (cached && now - cached.timestamp < (options?.revalidate || CACHE_DURATION)) {
    return cached.data;
  }
  
  const data = await fetcher();
  cache.set(key, { data, timestamp: now });
  
  return data;
}
```

## バンドルサイズ最適化

### 1. Tree Shaking
```typescript
// ❌ Bad: 全体をインポート
import * as Icons from '@/components/icons';

// ✅ Good: 必要な部分のみインポート
import { PlusIcon, TrashIcon } from '@/components/icons';
```

### 2. コード分割
```typescript
// app/admin/layout.tsx
// 管理者機能を独立したバンドルに分離
export default function AdminLayout({ children }) {
  return (
    <AdminProvider>
      <AdminSidebar />
      <main>{children}</main>
    </AdminProvider>
  );
}
```

### 3. 依存関係の最適化
```json
// package.json
{
  "dependencies": {
    // 軽量な代替ライブラリを使用
    "date-fns": "^2.0.0",      // moment.jsの代わり
    "clsx": "^2.0.0",          // classnamesの代わり
    "zustand": "^4.0.0"        // 軽量な状態管理
  }
}
```

## 画像最適化

### 1. Next.js Image コンポーネント
```typescript
import Image from 'next/image';

// 最適化された画像読み込み
export function ExpenseIcon({ src, alt }: ImageProps) {
  return (
    <Image
      src={src}
      alt={alt}
      width={48}
      height={48}
      loading="lazy"
      placeholder="blur"
      blurDataURL={generateBlurDataURL(src)}
      sizes="(max-width: 640px) 48px, 64px"
    />
  );
}
```

### 2. 適切な画像フォーマット
```typescript
// 画像フォーマットの自動選択
<Image
  src="/hero.jpg"
  alt="Hero"
  formats={['image/avif', 'image/webp']}
  quality={85}
/>
```

### 3. レスポンシブ画像
```typescript
// srcsetを使用した最適な画像配信
<Image
  src="/expense-chart"
  alt="支出グラフ"
  sizes="(max-width: 640px) 100vw, 
         (max-width: 1024px) 50vw,
         33vw"
  style={{
    width: '100%',
    height: 'auto',
  }}
/>
```

## ランタイムパフォーマンス

### 1. メモ化の適切な使用
```typescript
// 高コストな計算のメモ化
const ExpenseSummary = ({ expenses }: Props) => {
  const summary = useMemo(() => {
    return expenses.reduce((acc, expense) => {
      const category = expense.category || 'その他';
      acc[category] = (acc[category] || 0) + expense.amount;
      return acc;
    }, {} as Record<string, number>);
  }, [expenses]);

  const sortedCategories = useMemo(() => {
    return Object.entries(summary)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5);
  }, [summary]);

  return <SummaryChart data={sortedCategories} />;
};
```

### 2. イベントハンドラの最適化
```typescript
// デバウンスを使用した検索
import { useDebouncedCallback } from 'use-debounce';

export function SearchInput() {
  const [searchTerm, setSearchTerm] = useState('');
  
  const debouncedSearch = useDebouncedCallback(
    (value: string) => {
      // API呼び出し
      searchExpenses(value);
    },
    300 // 300ms のデバウンス
  );

  return (
    <input
      type="search"
      onChange={(e) => {
        setSearchTerm(e.target.value);
        debouncedSearch(e.target.value);
      }}
      value={searchTerm}
    />
  );
}
```

### 3. 仮想スクロール
```typescript
// 大量のリストアイテムの仮想化
import { FixedSizeList } from 'react-window';

export function LargeExpenseList({ expenses }: Props) {
  const Row = ({ index, style }) => (
    <div style={style}>
      <ExpenseItem expense={expenses[index]} />
    </div>
  );

  return (
    <FixedSizeList
      height={600}
      itemCount={expenses.length}
      itemSize={80}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

## Cloudflare Workers 最適化

### 1. エッジキャッシング
```typescript
// middleware.ts
export function middleware(request: Request) {
  const response = NextResponse.next();
  
  // 静的アセットのキャッシュ設定
  if (request.nextUrl.pathname.startsWith('/_next/static')) {
    response.headers.set('Cache-Control', 'public, max-age=31536000, immutable');
  }
  
  // APIレスポンスのキャッシュ
  if (request.nextUrl.pathname.startsWith('/api/categories')) {
    response.headers.set('Cache-Control', 'public, max-age=3600, s-maxage=3600');
  }
  
  return response;
}
```

### 2. Workers KV の活用
```typescript
// lib/kv-cache.ts
export async function getFromKV(key: string) {
  if (typeof window !== 'undefined') return null;
  
  const value = await KV_NAMESPACE.get(key);
  return value ? JSON.parse(value) : null;
}

export async function setToKV(key: string, value: any, ttl = 3600) {
  if (typeof window !== 'undefined') return;
  
  await KV_NAMESPACE.put(key, JSON.stringify(value), {
    expirationTtl: ttl,
  });
}
```

## 監視とデバッグ

### 1. パフォーマンス監視
```typescript
// app/layout.tsx
import { Analytics } from '@vercel/analytics/react';
import { SpeedInsights } from '@vercel/speed-insights/next';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        <Analytics />
        <SpeedInsights />
      </body>
    </html>
  );
}
```

### 2. カスタムパフォーマンスログ
```typescript
// lib/performance-logger.ts
export class PerformanceLogger {
  private marks = new Map<string, number>();

  mark(name: string) {
    this.marks.set(name, performance.now());
  }

  measure(name: string, startMark: string, endMark?: string) {
    const start = this.marks.get(startMark);
    const end = endMark ? this.marks.get(endMark) : performance.now();
    
    if (start && end) {
      const duration = end - start;
      console.log(`[Performance] ${name}: ${duration.toFixed(2)}ms`);
      
      // 閾値を超えた場合は警告
      if (duration > 1000) {
        console.warn(`[Performance Warning] ${name} took ${duration.toFixed(2)}ms`);
      }
    }
  }
}
```

## チェックリスト

### デプロイ前の確認事項
- [ ] Lighthouseスコアが目標値を満たしている
- [ ] バンドルサイズが適切（< 200KB for initial load）
- [ ] 画像が最適化されている
- [ ] 不要な依存関係が削除されている
- [ ] キャッシュヘッダーが適切に設定されている
- [ ] Critical CSSがインライン化されている
- [ ] フォントが最適化されている
- [ ] 3G環境でのテストが完了している

### 継続的な改善
1. **週次レビュー**: Core Web Vitalsの確認
2. **月次分析**: バンドルサイズとパフォーマンストレンド
3. **四半期評価**: 依存関係の見直しと最適化

## まとめ

パフォーマンス最適化は継続的なプロセスです。以下の原則を守ることが重要です：

1. **測定第一**: 推測ではなく、実データに基づいて最適化
2. **ユーザー中心**: 実際のユーザー体験を重視
3. **段階的改善**: 小さな改善を積み重ねる
4. **自動化**: パフォーマンステストをCI/CDに統合
5. **バランス**: 開発効率とパフォーマンスのバランス