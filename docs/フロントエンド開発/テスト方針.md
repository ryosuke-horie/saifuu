# フロントエンド テスト方針

## 概要

フロントエンドのテスト戦略は、品質を保証しながら開発効率を最大化することを目的としています。テストピラミッドの原則に従い、適切なレベルでのテストを実施します。

## テストレベルと責務

### 1. ユニットテスト（Vitest）
**対象**: 関数、フック、ユーティリティ、バリデーション

**テスト方針**: 重要な振る舞いとエッジケースを網羅的にテスト

```typescript
// lib/utils/__tests__/format.test.ts
import { formatCurrency, formatDate } from '../format';

describe('formatCurrency', () => {
  it('正の数値を日本円形式でフォーマットする', () => {
    expect(formatCurrency(1000)).toBe('¥1,000');
    expect(formatCurrency(1234567)).toBe('¥1,234,567');
  });

  it('負の数値を適切に処理する', () => {
    expect(formatCurrency(-500)).toBe('-¥500');
  });

  it('小数点を含む数値を処理する', () => {
    expect(formatCurrency(1234.56)).toBe('¥1,235');
  });

  it('0を適切に表示する', () => {
    expect(formatCurrency(0)).toBe('¥0');
  });
});
```

### 2. コンポーネントテスト（Storybook + Play Function）
**対象**: UIコンポーネントの表示とインタラクション

**方針**: 視覚的な確認とインタラクションテスト

```typescript
// components/common/Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import { expect, userEvent, within } from '@storybook/test';
import { Button } from './Button';

const meta: Meta<typeof Button> = {
  title: 'Common/Button',
  component: Button,
  argTypes: {
    onClick: { action: 'clicked' },
  },
};

export default meta;
type Story = StoryObj<typeof meta>;

export const Interactive: Story = {
  play: async ({ canvasElement, args }) => {
    const canvas = within(canvasElement);
    const button = canvas.getByRole('button');
    
    // ボタンが表示されている
    await expect(button).toBeInTheDocument();
    
    // クリック可能
    await userEvent.click(button);
    await expect(args.onClick).toHaveBeenCalledTimes(1);
    
    // ホバー状態
    await userEvent.hover(button);
    await expect(button).toHaveClass('hover:bg-blue-700');
  },
};
```

### 3. 統合テスト（Vitest + React Testing Library）
**対象**: 複数コンポーネントの連携、APIとの統合

**方針**: 主要な機能フローのテスト

```typescript
// features/expenses/__tests__/ExpenseForm.integration.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ExpenseForm } from '../ExpenseForm';
import { server } from '@/mocks/server';
import { http, HttpResponse } from 'msw';

describe('ExpenseForm Integration', () => {
  it('支出を正常に登録できる', async () => {
    const user = userEvent.setup();
    const onSuccess = vi.fn();
    
    render(<ExpenseForm onSuccess={onSuccess} />);
    
    // フォーム入力
    await user.type(screen.getByLabelText('金額'), '1500');
    await user.selectOptions(screen.getByLabelText('カテゴリ'), '食費');
    await user.type(screen.getByLabelText('メモ'), 'ランチ代');
    
    // 送信
    await user.click(screen.getByRole('button', { name: '登録' }));
    
    // 成功確認
    await waitFor(() => {
      expect(onSuccess).toHaveBeenCalledWith(
        expect.objectContaining({
          amount: 1500,
          category: '食費',
          memo: 'ランチ代',
        })
      );
    });
  });

  it('APIエラー時にエラーメッセージを表示する', async () => {
    server.use(
      http.post('/api/expenses', () => {
        return HttpResponse.json(
          { error: 'Internal Server Error' },
          { status: 500 }
        );
      })
    );
    
    const user = userEvent.setup();
    render(<ExpenseForm />);
    
    await user.type(screen.getByLabelText('金額'), '1000');
    await user.click(screen.getByRole('button', { name: '登録' }));
    
    await waitFor(() => {
      expect(screen.getByText('登録に失敗しました')).toBeInTheDocument();
    });
  });
});
```

### 4. E2Eテスト（Playwright）
**対象**: 正常系の主要ユーザーフローのみ

**方針**: 最小限のシナリオで全体の動作を確認

```typescript
// e2e/expenses.spec.ts
import { test, expect } from '@playwright/test';

test.describe('支出管理', () => {
  test('支出の登録から一覧表示までの基本フロー', async ({ page }) => {
    await page.goto('/expenses');
    
    // 新規登録ボタンをクリック
    await page.getByRole('button', { name: '新規登録' }).click();
    
    // フォーム入力
    await page.getByLabel('金額').fill('3000');
    await page.getByLabel('カテゴリ').selectOption('食費');
    await page.getByLabel('メモ').fill('夕食代');
    
    // 登録
    await page.getByRole('button', { name: '登録' }).click();
    
    // 一覧に表示されることを確認
    await expect(page.getByText('¥3,000')).toBeVisible();
    await expect(page.getByText('食費')).toBeVisible();
    await expect(page.getByText('夕食代')).toBeVisible();
  });
});
```

## テスト対象の優先順位

### 高優先度
1. **ビジネスロジック**: 金額計算、データ変換、バリデーション
2. **カスタムフック**: データフェッチング、状態管理
3. **主要なユーザーフロー**: 登録、編集、削除の基本操作
4. **エラーハンドリング**: エラー状態の適切な処理

### 中優先度
1. **複雑なコンポーネント**: 条件分岐が多い、状態を持つ
2. **フォーム処理**: バリデーション、送信処理
3. **API連携**: レスポンス変換、エラー処理

### 低優先度
1. **単純な表示コンポーネント**: 静的なUI
2. **スタイリング**: 見た目のみの変更
3. **サードパーティライブラリ**: 既にテスト済みの外部ライブラリ

## テスト記述のガイドライン

### 1. テストの構造（AAA パターン）
```typescript
it('説明的なテスト名', () => {
  // Arrange（準備）
  const mockData = { id: 1, amount: 1000 };
  const onUpdate = vi.fn();
  
  // Act（実行）
  const result = updateExpense(mockData, onUpdate);
  
  // Assert（検証）
  expect(result).toEqual(expectedResult);
  expect(onUpdate).toHaveBeenCalledWith(mockData);
});
```

### 2. テストの命名規則
```typescript
// 日本語で何をテストしているか明確に記述
describe('formatCurrency', () => {
  it('正の数値を日本円形式でフォーマットする');
  it('負の数値にマイナス記号を付与する');
  it('小数点以下を四捨五入する');
  it('nullやundefinedを0として処理する');
});
```

### 3. モックとスタブ
```typescript
// APIモック（MSW使用）
import { setupServer } from 'msw/node';
import { http, HttpResponse } from 'msw';

const server = setupServer(
  http.get('/api/expenses', () => {
    return HttpResponse.json([
      { id: 1, amount: 1000, category: '食費' },
      { id: 2, amount: 2000, category: '交通費' },
    ]);
  })
);

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

## テストユーティリティ

### 1. カスタムレンダー関数
```typescript
// test-utils/render.tsx
import { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
    },
  });

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>
) => render(ui, { wrapper: AllTheProviders, ...options });

export * from '@testing-library/react';
export { customRender as render };
```

### 2. テストデータファクトリ
```typescript
// test-utils/factories.ts
export const createExpense = (overrides = {}): Expense => ({
  id: '1',
  amount: 1000,
  category: '食費',
  memo: '',
  date: new Date().toISOString(),
  ...overrides,
});

export const createCategory = (overrides = {}): Category => ({
  id: '1',
  name: '食費',
  color: '#FF6B6B',
  ...overrides,
});
```

## CI/CD統合

### GitHub Actionsでのテスト実行
```yaml
# .github/workflows/test.yml
name: Frontend Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '22'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run type check
        run: npm run type-check
        
      - name: Run linter
        run: npm run lint
        
      - name: Run unit tests
        run: npm run test:unit -- --coverage
        
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
```

## テストのベストプラクティス

### Do's ✅
- 一つのテストで一つの振る舞いをテスト
- 具体的で説明的なテスト名
- テストの独立性を保つ
- 実装の詳細ではなく振る舞いをテスト
- エッジケースとエラーケースをカバー

### Don'ts ❌
- 実装の詳細に依存したテスト
- 複雑すぎるモック
- sleepやwaitForを過度に使用
- テストのためだけのコード追加
- 外部サービスに依存したテスト

## トラブルシューティング

### よくある問題と解決方法

#### 1. act警告
```typescript
// 問題: Warning: An update to Component inside a test was not wrapped in act(...)
// 解決策
await waitFor(() => {
  expect(screen.getByText('更新完了')).toBeInTheDocument();
});
```

#### 2. タイムアウトエラー
```typescript
// 問題: Timed out in waitFor after 1000ms
// 解決策: タイムアウトを延長
await waitFor(
  () => expect(screen.getByText('データ')).toBeInTheDocument(),
  { timeout: 3000 }
);
```

#### 3. モックが効かない
```typescript
// 問題: モジュールのモックが効かない
// 解決策: vi.mock をファイルのトップレベルに配置
vi.mock('@/lib/api/client');

describe('Component', () => {
  // テスト
});
```

## まとめ

フロントエンドのテスト戦略は以下の原則に基づいています：

1. **適切なレベルでのテスト**: テストピラミッドに従った効率的なテスト
2. **保守性**: 変更に強く、理解しやすいテスト
3. **実行速度**: 高速なフィードバックループ
4. **信頼性**: 偽陽性・偽陰性を最小化
5. **開発体験**: テストが開発を助ける