# コンポーネント設計ガイド

## 設計原則

### 1. 単一責任の原則（SRP）
各コンポーネントは一つの明確な責務を持つべきです。複数の関心事が混在する場合は、コンポーネントを分割します。

### 2. 合成可能性（Composability）
小さく独立したコンポーネントを組み合わせて、より複雑なUIを構築します。

### 3. 再利用性（Reusability）
汎用的なコンポーネントは`components/common`に配置し、プロジェクト全体で再利用します。

## コンポーネントの分類

### 1. プレゼンテーショナルコンポーネント
- UIの見た目のみに責任を持つ
- propsを通じてデータを受け取る
- 状態を持たない（または最小限）

```typescript
// components/common/Button.tsx
type ButtonProps = {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  children: React.ReactNode;
  onClick?: () => void;
  disabled?: boolean;
};

export function Button({ variant = 'primary', size = 'md', ...props }: ButtonProps) {
  return <button className={buttonStyles(variant, size)} {...props} />;
}
```

### 2. コンテナコンポーネント
- ビジネスロジックとデータ取得に責任を持つ
- 子コンポーネントにデータを渡す
- Server Componentsとして実装可能

```typescript
// app/expenses/ExpenseListContainer.tsx
export async function ExpenseListContainer() {
  const expenses = await fetchExpenses();
  
  return (
    <ExpenseList 
      expenses={expenses}
      onDelete={deleteExpense}
      onEdit={editExpense}
    />
  );
}
```

### 3. 複合コンポーネント（Compound Components）
- 関連する複数のコンポーネントをグループ化
- 柔軟な組み合わせを可能にする

```typescript
// components/features/expenses/ExpenseCard.tsx
export function ExpenseCard({ children }: { children: React.ReactNode }) {
  return <div className="expense-card">{children}</div>;
}

ExpenseCard.Header = function Header({ children }: { children: React.ReactNode }) {
  return <div className="expense-card-header">{children}</div>;
};

ExpenseCard.Body = function Body({ children }: { children: React.ReactNode }) {
  return <div className="expense-card-body">{children}</div>;
};

ExpenseCard.Actions = function Actions({ children }: { children: React.ReactNode }) {
  return <div className="expense-card-actions">{children}</div>;
};
```

## ファイル構成

### 基本構造
```
components/
├── common/
│   ├── Button/
│   │   ├── Button.tsx          # コンポーネント本体
│   │   ├── Button.test.tsx     # テスト
│   │   └── index.ts           # エクスポート
│   └── Input/
│       └── ...
├── features/
│   ├── expenses/
│   │   ├── ExpenseList/
│   │   ├── ExpenseForm/
│   │   └── ExpenseCard/
│   └── ...
└── layouts/
    ├── Header/
    ├── Footer/
    └── Sidebar/
```

## 命名規則

### コンポーネント名
- PascalCase を使用
- 意味のある、説明的な名前
- 機能を表す動詞＋名詞の組み合わせ

```typescript
// 良い例
<ExpenseList />
<CreateExpenseButton />
<MonthlyExpenseChart />

// 悪い例
<List />
<Button2 />
<Chart />
```

### Props インターフェース
- コンポーネント名 + `Props` のパターン
- 明確な型定義

```typescript
type ExpenseListProps = {
  expenses: Expense[];
  onDelete: (id: string) => void;
  onEdit: (id: string, data: ExpenseUpdateData) => void;
};
```

## Server Components vs Client Components

### Server Components を使用する場合
- データフェッチングが必要
- 静的なコンテンツの表示
- SEOが重要なページ

### Client Components を使用する場合
- ユーザーインタラクションが必要（onClick, onChange等）
- ブラウザAPIの使用（useState, useEffect等）
- リアルタイムな状態変更

```typescript
// Server Component
// app/expenses/page.tsx
export default async function ExpensesPage() {
  const expenses = await fetchExpenses();
  return <ExpenseList expenses={expenses} />;
}

// Client Component
// components/features/expenses/ExpenseForm.tsx
'use client';

export function ExpenseForm() {
  const [formData, setFormData] = useState({});
  // インタラクティブなフォーム処理
}
```

## スタイリングガイドライン

### Tailwind CSS の使用
```typescript
// 基本的な使用方法
<div className="flex items-center gap-4 p-4 bg-white rounded-lg shadow-sm">
  {/* コンテンツ */}
</div>

// 条件付きスタイリング
<button
  className={cn(
    "px-4 py-2 rounded-md font-medium transition-colors",
    variant === 'primary' && "bg-blue-500 text-white hover:bg-blue-600",
    variant === 'secondary' && "bg-gray-200 text-gray-800 hover:bg-gray-300",
    disabled && "opacity-50 cursor-not-allowed"
  )}
>
  {children}
</button>
```

### コンポーネント固有のスタイル
```typescript
// スタイル定数の定義
const styles = {
  container: "max-w-4xl mx-auto p-6",
  header: "flex justify-between items-center mb-6",
  list: "space-y-4",
  item: "bg-white p-4 rounded-lg shadow-sm hover:shadow-md transition-shadow",
};

// 使用
<div className={styles.container}>
  <header className={styles.header}>
    {/* ヘッダーコンテンツ */}
  </header>
  <ul className={styles.list}>
    {/* リストアイテム */}
  </ul>
</div>
```

## アクセシビリティ

### 基本要件
- セマンティックなHTML要素の使用
- 適切なARIA属性の追加
- キーボードナビゲーションのサポート

```typescript
// アクセシブルなボタン
<button
  aria-label="支出を削除"
  aria-describedby="delete-expense-description"
  onClick={handleDelete}
>
  <TrashIcon />
</button>
<span id="delete-expense-description" className="sr-only">
  この支出項目を削除します
</span>

// アクセシブルなフォーム
<form onSubmit={handleSubmit}>
  <label htmlFor="amount" className="block text-sm font-medium">
    金額
    <span className="text-red-500 ml-1" aria-label="必須">*</span>
  </label>
  <input
    id="amount"
    type="number"
    required
    aria-required="true"
    aria-invalid={errors.amount ? 'true' : 'false'}
    aria-describedby={errors.amount ? 'amount-error' : undefined}
  />
  {errors.amount && (
    <p id="amount-error" className="text-red-500 text-sm mt-1">
      {errors.amount.message}
    </p>
  )}
</form>
```

## パフォーマンス最適化

### 1. メモ化の活用
```typescript
// 重い計算処理のメモ化
const ExpenseSummary = memo(({ expenses }: { expenses: Expense[] }) => {
  const total = useMemo(
    () => expenses.reduce((sum, exp) => sum + exp.amount, 0),
    [expenses]
  );
  
  return <div>合計: {total}円</div>;
});
```

### 2. 動的インポート
```typescript
// 大きなコンポーネントの遅延読み込み
const ExpenseChart = dynamic(
  () => import('@/components/features/expenses/ExpenseChart'),
  {
    loading: () => <ChartSkeleton />,
    ssr: false,
  }
);
```

### 3. 画像の最適化
```typescript
import Image from 'next/image';

<Image
  src="/expense-icon.png"
  alt="支出アイコン"
  width={48}
  height={48}
  loading="lazy"
/>
```

## テスト戦略

### ユニットテスト
```typescript
// Button.test.tsx
describe('Button', () => {
  it('正しいvariantクラスが適用される', () => {
    render(<Button variant="primary">テスト</Button>);
    const button = screen.getByRole('button');
    expect(button).toHaveClass('bg-blue-500');
  });
  
  it('クリックイベントが発火する', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>クリック</Button>);
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### E2Eテスト
最小限の正常系フローのテストをPlaywrightで実装し、主要なユーザーフローの動作確認を行います。

## ベストプラクティス

### 1. Props の設計
- 必要最小限のpropsに留める
- デフォルト値を適切に設定
- 型安全性を確保

### 2. エラーハンドリング
- エラー状態を適切に表示
- ユーザーフレンドリーなメッセージ
- リカバリー方法の提示

### 3. ローディング状態
- スケルトンスクリーンの活用
- プログレスインジケーターの表示
- 適切なフィードバック

### 4. 国際化対応（将来的な拡張性）
- ハードコードされた文字列を避ける
- 日付・数値のフォーマット対応
- レイアウトの柔軟性確保