# フロントエンドロガー設計

## 概要

Saifuu家計管理アプリケーションのフロントエンドロギングシステムの設計仕様書です。Next.js 15 + React 19環境での高性能な構造化ログ機能を提供し、開発・運用の効率化とユーザーエクスペリエンスの向上を実現します。

## 設計目標

### 1. React 19 最適化
- 新しいOwner Stack機能を活用したコンポーネント階層デバッグ
- 並行レンダリング機能との適切な統合
- useTransition、Suspenseに対応したログ戦略

### 2. Next.js 15 統合
- SSR/CSR両対応のログ戦略
- クライアントサイド計測（instrumentation-client.js）活用
- ハイドレーション問題の適切な対処

### 3. 開発・運用効率化
- Storybookコンポーネント開発との統合
- APIロガーとの完全なrequestId相関
- 型安全なログ機能
- デバッグとトラブルシューティングの簡素化

### 4. パフォーマンス最適化
- バンドルサイズへの最小限の影響
- ブラウザ実行時パフォーマンスの維持
- メモリ効率的なバッファリング

## アーキテクチャ設計

### 1. コアインターフェース

```typescript
// frontend/src/lib/logger/types.ts
export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LogMeta {
  requestId?: string;
  userId?: string;
  component?: string;
  action?: string;
  path?: string;
  duration?: number;
  data?: Record<string, any>;
  error?: Error | string;
  stack?: string;
  [key: string]: any;
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  requestId: string;
  environment: 'development' | 'production' | 'storybook';
  session: string;
  meta: LogMeta;
}

export interface LoggerConfig {
  environment: 'development' | 'production' | 'storybook';
  level: LogLevel;
  bufferSize: number;
  flushInterval: number;
  enableConsole: boolean;
  apiEndpoint?: string;
}

export interface FrontendLogger {
  debug(message: string, meta?: LogMeta): void;
  info(message: string, meta?: LogMeta): void;
  warn(message: string, meta?: LogMeta): void;
  error(message: string, meta?: LogMeta): void;
  trackUserAction(action: string, meta?: LogMeta): void;
  trackPageView(path: string, meta?: LogMeta): void;
  trackApiCall(endpoint: string, method: string, meta?: LogMeta): void;
}
```

### 2. React統合 - Context & Hooks

```typescript
// frontend/src/lib/logger/context.tsx
'use client';

import { createContext, useContext, useCallback, useRef } from 'react';
import { FrontendLogger, LogMeta } from './types';
import { createBrowserLogger } from './browser-logger';

const LoggerContext = createContext<FrontendLogger | null>(null);

export function LoggerProvider({ children }: { children: React.ReactNode }) {
  const loggerRef = useRef<FrontendLogger | null>(null);
  
  if (!loggerRef.current) {
    loggerRef.current = createBrowserLogger();
  }

  return (
    <LoggerContext.Provider value={loggerRef.current}>
      {children}
    </LoggerContext.Provider>
  );
}

export function useLogger(): FrontendLogger {
  const logger = useContext(LoggerContext);
  if (!logger) {
    throw new Error('useLogger must be used within LoggerProvider');
  }
  return logger;
}

// コンポーネント専用フック
export function useComponentLogger(componentName: string) {
  const logger = useLogger();
  
  return {
    debug: useCallback((message: string, meta?: LogMeta) => {
      logger.debug(message, { ...meta, component: componentName });
    }, [logger, componentName]),
    
    info: useCallback((message: string, meta?: LogMeta) => {
      logger.info(message, { ...meta, component: componentName });
    }, [logger, componentName]),
    
    warn: useCallback((message: string, meta?: LogMeta) => {
      logger.warn(message, { ...meta, component: componentName });
    }, [logger, componentName]),
    
    error: useCallback((message: string, meta?: LogMeta) => {
      logger.error(message, { ...meta, component: componentName });
    }, [logger, componentName]),
    
    trackAction: useCallback((action: string, meta?: LogMeta) => {
      logger.trackUserAction(action, { ...meta, component: componentName });
    }, [logger, componentName]),
  };
}

// ユーザーアクション自動ログフック
export function useLoggedCallback<T extends any[]>(
  callback: (...args: T) => void,
  action: string,
  deps: React.DependencyList,
  meta?: LogMeta
) {
  const logger = useLogger();
  
  return useCallback((...args: T) => {
    const startTime = performance.now();
    
    try {
      logger.trackUserAction(`${action} started`, meta);
      callback(...args);
      
      const duration = performance.now() - startTime;
      logger.trackUserAction(`${action} completed`, { ...meta, duration });
    } catch (error) {
      const duration = performance.now() - startTime;
      logger.error(`${action} failed`, { 
        ...meta, 
        duration, 
        error: error instanceof Error ? error.message : String(error) 
      });
      throw error;
    }
  }, [...deps, logger, action]);
}
```

### 3. ブラウザ最適化ロガー

```typescript
// frontend/src/lib/logger/browser-logger.ts
import { FrontendLogger, LogLevel, LogEntry, LogMeta, LoggerConfig } from './types';
import { generateRequestId } from './utils';

export class BrowserLogger implements FrontendLogger {
  private config: LoggerConfig;
  private buffer: LogEntry[] = [];
  private sessionId: string;
  private flushTimer: number | null = null;

  constructor(config: LoggerConfig) {
    this.config = config;
    this.sessionId = generateRequestId();
    this.setupPeriodicFlush();
    this.setupVisibilityHandler();
  }

  debug(message: string, meta: LogMeta = {}): void {
    this.log('debug', message, meta);
  }

  info(message: string, meta: LogMeta = {}): void {
    this.log('info', message, meta);
  }

  warn(message: string, meta: LogMeta = {}): void {
    this.log('warn', message, meta);
  }

  error(message: string, meta: LogMeta = {}): void {
    this.log('error', message, meta);
  }

  trackUserAction(action: string, meta: LogMeta = {}): void {
    this.log('info', `User action: ${action}`, { 
      ...meta, 
      action,
      userAction: true 
    });
  }

  trackPageView(path: string, meta: LogMeta = {}): void {
    this.log('info', `Page view: ${path}`, { 
      ...meta, 
      path,
      pageView: true 
    });
  }

  trackApiCall(endpoint: string, method: string, meta: LogMeta = {}): void {
    this.log('info', `API call: ${method} ${endpoint}`, { 
      ...meta, 
      endpoint,
      method,
      apiCall: true 
    });
  }

  private log(level: LogLevel, message: string, meta: LogMeta): void {
    if (!this.shouldLog(level)) return;

    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      requestId: meta.requestId || generateRequestId(),
      environment: this.config.environment,
      session: this.sessionId,
      meta: {
        ...meta,
        url: typeof window !== 'undefined' ? window.location.href : undefined,
        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,
      }
    };

    if (this.config.enableConsole) {
      this.logToConsole(entry);
    }

    this.buffer.push(entry);
    
    if (this.buffer.length >= this.config.bufferSize) {
      this.flushBuffer();
    }
  }

  private logToConsole(entry: LogEntry): void {
    const consoleMethod = entry.level === 'debug' ? 'debug' : 
                         entry.level === 'warn' ? 'warn' : 
                         entry.level === 'error' ? 'error' : 'log';
    
    if (this.config.environment === 'development') {
      console[consoleMethod]('[FRONTEND]', entry.message, entry.meta);
    } else {
      console[consoleMethod](`[${entry.level.toUpperCase()}] ${entry.message}`);
    }
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = { debug: 0, info: 1, warn: 2, error: 3 };
    return levels[level] >= levels[this.config.level];
  }

  private setupPeriodicFlush(): void {
    if (typeof window !== 'undefined') {
      this.flushTimer = window.setInterval(() => {
        this.flushBuffer();
      }, this.config.flushInterval);
    }
  }

  private setupVisibilityHandler(): void {
    if (typeof document !== 'undefined') {
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          this.flushBuffer();
        }
      });
      
      window.addEventListener('beforeunload', () => {
        this.flushBuffer();
      });
    }
  }

  private async flushBuffer(): Promise<void> {
    if (this.buffer.length === 0) return;

    const entries = [...this.buffer];
    this.buffer = [];

    try {
      if (this.config.apiEndpoint && this.config.environment === 'production') {
        await this.sendToServer(entries);
      }
    } catch (error) {
      console.error('Failed to send logs to server:', error);
    }
  }

  private async sendToServer(entries: LogEntry[]): Promise<void> {
    if (!this.config.apiEndpoint) return;

    try {
      await fetch(this.config.apiEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ logs: entries }),
      });
    } catch (error) {
      // ログ送信失敗時はコンソールにフォールバック
      entries.forEach(entry => this.logToConsole(entry));
    }
  }

  destroy(): void {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    this.flushBuffer();
  }
}

export function createBrowserLogger(config?: Partial<LoggerConfig>): FrontendLogger {
  const defaultConfig: LoggerConfig = {
    environment: process.env.NODE_ENV === 'production' ? 'production' : 'development',
    level: process.env.NODE_ENV === 'production' ? 'warn' : 'debug',
    bufferSize: 50,
    flushInterval: 5000,
    enableConsole: true,
    apiEndpoint: process.env.NEXT_PUBLIC_LOGGER_ENDPOINT,
  };

  return new BrowserLogger({ ...defaultConfig, ...config });
}
```

### 4. エラーバウンダリ強化

```typescript
// frontend/src/components/ErrorBoundary.tsx
'use client';

import React, { ErrorInfo, ReactNode } from 'react';
import { useLogger } from '../lib/logger/context';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
  errorInfo?: ErrorInfo;
}

export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  private logger?: any;

  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({ errorInfo });
    
    // ログ記録
    if (this.logger) {
      this.logger.error('React Error Boundary caught error', {
        error: error.message,
        stack: error.stack,
        componentStack: errorInfo.componentStack,
        errorBoundary: true,
      });
    }

    // カスタムエラーハンドラー実行
    this.props.onError?.(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div className="error-boundary">
          <h2>エラーが発生しました</h2>
          <details>
            <summary>詳細を表示</summary>
            <pre>{this.state.error?.stack}</pre>
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}

// HOC版エラーバウンダリ
export function withErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  errorFallback?: ReactNode
) {
  return function WrappedComponent(props: P) {
    return (
      <ErrorBoundary fallback={errorFallback}>
        <Component {...props} />
      </ErrorBoundary>
    );
  };
}
```

### 5. API統合とrequestId相関

```typescript
// frontend/src/lib/api/client.ts の拡張
import { useLogger } from '../logger/context';

// 既存APIクライアントの拡張
export function enhanceApiClientWithLogging(apiClient: any) {
  const logger = useLogger();

  // リクエストインターセプター
  apiClient.interceptors.request.use((config: any) => {
    const requestId = generateRequestId();
    
    // requestIdをヘッダーに追加
    config.headers['X-Request-ID'] = requestId;
    
    // APIコール開始ログ
    logger.trackApiCall(config.url, config.method.toUpperCase(), {
      requestId,
      data: config.data,
    });

    config.metadata = { requestId, startTime: performance.now() };
    return config;
  });

  // レスポンスインターセプター
  apiClient.interceptors.response.use(
    (response: any) => {
      const { requestId, startTime } = response.config.metadata;
      const duration = performance.now() - startTime;

      logger.info('API call completed', {
        requestId,
        status: response.status,
        duration,
        endpoint: response.config.url,
        method: response.config.method,
      });

      return response;
    },
    (error: any) => {
      const { requestId, startTime } = error.config?.metadata || {};
      const duration = startTime ? performance.now() - startTime : undefined;

      logger.error('API call failed', {
        requestId,
        status: error.response?.status,
        duration,
        endpoint: error.config?.url,
        method: error.config?.method,
        error: error.message,
        stack: error.stack,
      });

      return Promise.reject(error);
    }
  );

  return apiClient;
}
```

### 6. Next.js統合

```typescript
// frontend/src/app/layout.tsx での統合
import { LoggerProvider } from '../lib/logger/context';
import { ErrorBoundary } from '../components/ErrorBoundary';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ja">
      <body>
        <LoggerProvider>
          <ErrorBoundary>
            {children}
          </ErrorBoundary>
        </LoggerProvider>
      </body>
    </html>
  );
}

// middleware.ts でのログ追跡
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  const requestId = request.headers.get('X-Request-ID') || generateRequestId();
  
  // レスポンスヘッダーにrequestIdを追加
  const response = NextResponse.next();
  response.headers.set('X-Request-ID', requestId);
  
  return response;
}
```

### 7. Storybook統合

```typescript
// .storybook/preview.tsx での統合
import { LoggerProvider, createBrowserLogger } from '../frontend/src/lib/logger';

// Storybook専用ロガー設定
const storybookLogger = createBrowserLogger({
  environment: 'storybook',
  level: 'debug',
  enableConsole: true,
  bufferSize: 10,
  flushInterval: 1000,
});

export const decorators = [
  (Story) => (
    <LoggerProvider value={storybookLogger}>
      <Story />
    </LoggerProvider>
  ),
];

// Storybookアクション統合
export const parameters = {
  actions: {
    handles: ['mouseover', 'click .btn'],
  },
  logger: {
    onAction: (action: string, args: any[]) => {
      storybookLogger.trackUserAction(`storybook:${action}`, { args });
    },
  },
};
```

### 8. パフォーマンス監視

```typescript
// frontend/src/lib/logger/performance.ts
import { useLogger } from './context';
import { useEffect, useRef } from 'react';

export function usePerformanceLogger(componentName: string) {
  const logger = useLogger();
  const renderStartTime = useRef<number>();

  useEffect(() => {
    renderStartTime.current = performance.now();
    
    return () => {
      if (renderStartTime.current) {
        const renderTime = performance.now() - renderStartTime.current;
        logger.debug(`Component render time: ${componentName}`, {
          component: componentName,
          renderTime,
          performance: true,
        });
      }
    };
  });

  return {
    markStart: (operation: string) => {
      const startTime = performance.now();
      return () => {
        const duration = performance.now() - startTime;
        logger.debug(`${operation} completed`, {
          component: componentName,
          operation,
          duration,
          performance: true,
        });
      };
    },
  };
}

// Web Vitals統合
export function setupWebVitalsLogging() {
  if (typeof window !== 'undefined') {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      const logger = createBrowserLogger();
      
      getCLS((metric) => logger.info('Web Vitals: CLS', { metric, vitals: true }));
      getFID((metric) => logger.info('Web Vitals: FID', { metric, vitals: true }));
      getFCP((metric) => logger.info('Web Vitals: FCP', { metric, vitals: true }));
      getLCP((metric) => logger.info('Web Vitals: LCP', { metric, vitals: true }));
      getTTFB((metric) => logger.info('Web Vitals: TTFB', { metric, vitals: true }));
    });
  }
}
```

## 設定システム

### 1. 環境別設定

```typescript
// frontend/src/lib/logger/config.ts
export const createLoggerConfig = (): LoggerConfig => {
  const isDevelopment = process.env.NODE_ENV === 'development';
  const isStorybook = process.env.STORYBOOK === 'true';
  
  if (isStorybook) {
    return {
      environment: 'storybook',
      level: 'debug',
      bufferSize: 10,
      flushInterval: 1000,
      enableConsole: true,
    };
  }

  return {
    environment: isDevelopment ? 'development' : 'production',
    level: isDevelopment ? 'debug' : 'warn',
    bufferSize: isDevelopment ? 10 : 100,
    flushInterval: isDevelopment ? 1000 : 10000,
    enableConsole: isDevelopment,
    apiEndpoint: process.env.NEXT_PUBLIC_LOGGER_ENDPOINT,
  };
};
```

### 2. 環境変数

```bash
# .env.local
NEXT_PUBLIC_LOGGER_ENDPOINT=https://api.saifuu.com/logs
NEXT_PUBLIC_LOG_LEVEL=debug

# .env.production
NEXT_PUBLIC_LOGGER_ENDPOINT=https://api.saifuu.com/logs
NEXT_PUBLIC_LOG_LEVEL=warn
```

## テスト戦略

### 1. ユニットテスト

```typescript
// frontend/src/lib/logger/__tests__/browser-logger.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { BrowserLogger } from '../browser-logger';

describe('BrowserLogger', () => {
  let logger: BrowserLogger;

  beforeEach(() => {
    logger = new BrowserLogger({
      environment: 'development',
      level: 'debug',
      bufferSize: 5,
      flushInterval: 100,
      enableConsole: true,
    });
    
    vi.spyOn(console, 'log').mockImplementation(() => {});
  });

  it('should log messages to console in development', () => {
    logger.info('Test message', { component: 'TestComponent' });
    
    expect(console.log).toHaveBeenCalledWith(
      '[FRONTEND]',
      'Test message',
      expect.objectContaining({ component: 'TestComponent' })
    );
  });

  it('should track user actions with proper metadata', () => {
    logger.trackUserAction('button_click', { buttonId: 'save-btn' });
    
    expect(console.log).toHaveBeenCalledWith(
      '[FRONTEND]',
      'User action: button_click',
      expect.objectContaining({ 
        action: 'button_click',
        buttonId: 'save-btn',
        userAction: true 
      })
    );
  });
});
```

### 2. React Hook テスト

```typescript
// frontend/src/lib/logger/__tests__/hooks.test.tsx
import { renderHook } from '@testing-library/react';
import { useComponentLogger } from '../context';
import { LoggerProvider } from '../context';

const wrapper = ({ children }: { children: React.ReactNode }) => (
  <LoggerProvider>{children}</LoggerProvider>
);

describe('useComponentLogger', () => {
  it('should include component name in logs', () => {
    const { result } = renderHook(
      () => useComponentLogger('TestComponent'),
      { wrapper }
    );

    const consoleSpy = vi.spyOn(console, 'log');
    result.current.info('Test message');

    expect(consoleSpy).toHaveBeenCalledWith(
      '[FRONTEND]',
      'Test message',
      expect.objectContaining({ component: 'TestComponent' })
    );
  });
});
```

## 実装フェーズ

### フェーズ1: 基盤構築
1. コアインターフェースとタイプ定義
2. BrowserLoggerクラス実装
3. 設定システム構築

### フェーズ2: React統合
1. LoggerContext & Providerの実装
2. React Hooks（useLogger, useComponentLogger）
3. エラーバウンダリ強化

### フェーズ3: 統合とツール連携
1. API統合とrequestId相関
2. Next.js統合（レイアウト、ミドルウェア）
3. Storybook統合

### フェーズ4: 最適化と監視
1. パフォーマンス監視機能
2. Web Vitals統合
3. 本番環境最適化

## 今後の拡張

### 1. 高度な分析
- ユーザー行動パターン分析
- パフォーマンス傾向の可視化
- エラー発生パターンの分析

### 2. 外部サービス連携
- LogRocket、Sentry等との統合
- カスタムダッシュボード構築
- アラート機能の実装

### 3. 開発者体験向上
- VSCode拡張機能
- デバッグツール強化
- ログ検索・フィルタリング機能

---

この設計により、SaifuuアプリケーションはモダンなReact開発環境に最適化された包括的なフロントエンドログ機能を獲得し、開発・運用の効率化とユーザーエクスペリエンスの向上を実現します。