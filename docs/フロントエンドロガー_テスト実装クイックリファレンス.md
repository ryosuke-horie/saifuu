# フロントエンドロガー テスト実装 クイックリファレンス

## 実装順序

### 1. 基本構造の作成

```bash
# ディレクトリ構造の作成
mkdir -p frontend/src/lib/logger/__tests__/{fixtures,mocks,utils}
```

### 2. 必要なファイルの作成順序

1. **型定義とテスト** → `types.ts` + `types.test.ts`
2. **設定とテスト** → `config.ts` + `config.test.ts`
3. **メインロガーとテスト** → `browser-logger.ts` + `browser-logger.test.ts`

### 3. テストセットアップ

#### vitest.config.ts
```typescript
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/lib/logger/__tests__/setup.ts'],
    globals: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  }
});
```

#### setup.ts
```typescript
import { beforeEach, afterEach, vi } from 'vitest';

beforeEach(() => {
  // DOM環境のリセット
  document.body.innerHTML = '';
  
  // API モック
  global.fetch = vi.fn();
  global.localStorage = {
    getItem: vi.fn(),
    setItem: vi.fn(),
    removeItem: vi.fn(),
    clear: vi.fn()
  };
  
  // タイマーモック
  vi.useFakeTimers();
});

afterEach(() => {
  vi.clearAllMocks();
  vi.useRealTimers();
});
```

## テストケース例

### types.test.ts
```typescript
import { describe, it, expect } from 'vitest';
import type { LogLevel, LogMessage, LoggerConfig } from './types';

describe('Logger Types', () => {
  it('should validate LogLevel values', () => {
    const validLevels: LogLevel[] = ['debug', 'info', 'warn', 'error', 'silent'];
    expect(validLevels).toHaveLength(5);
  });

  it('should validate LogMessage structure', () => {
    const message: LogMessage = {
      level: 'info',
      message: 'test',
      timestamp: new Date(),
      context: {}
    };
    
    expect(message.level).toBe('info');
    expect(message.message).toBe('test');
    expect(message.timestamp).toBeInstanceOf(Date);
    expect(message.context).toEqual({});
  });
});
```

### config.test.ts
```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { getLoggerConfig, validateConfig } from './config';

describe('Logger Config', () => {
  beforeEach(() => {
    delete process.env.NODE_ENV;
  });

  it('should return development config', () => {
    process.env.NODE_ENV = 'development';
    const config = getLoggerConfig();
    
    expect(config.level).toBe('debug');
    expect(config.bufferSize).toBe(50);
  });

  it('should validate buffer size', () => {
    expect(() => validateConfig({ bufferSize: 0 })).toThrow();
    expect(() => validateConfig({ bufferSize: 1001 })).toThrow();
    expect(() => validateConfig({ bufferSize: 100 })).not.toThrow();
  });
});
```

### browser-logger.test.ts
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { BrowserLogger } from './browser-logger';

describe('BrowserLogger', () => {
  let logger: BrowserLogger;

  beforeEach(() => {
    logger = new BrowserLogger();
  });

  describe('Logging Methods', () => {
    it('should log debug messages', () => {
      const consoleSpy = vi.spyOn(console, 'debug');
      logger.debug('debug message');
      expect(consoleSpy).toHaveBeenCalledWith('debug message');
    });

    it('should respect log level', () => {
      logger = new BrowserLogger({ level: 'error' });
      const consoleSpy = vi.spyOn(console, 'info');
      
      logger.info('info message');
      expect(consoleSpy).not.toHaveBeenCalled();
    });
  });

  describe('Buffer Management', () => {
    it('should buffer messages', () => {
      logger.info('message 1');
      logger.info('message 2');
      
      expect(logger.getBuffer()).toHaveLength(2);
    });

    it('should flush when buffer is full', () => {
      logger = new BrowserLogger({ bufferSize: 2 });
      const flushSpy = vi.spyOn(logger, 'flush');
      
      logger.info('message 1');
      logger.info('message 2');
      logger.info('message 3'); // Triggers flush
      
      expect(flushSpy).toHaveBeenCalled();
    });
  });

  describe('Auto Flush', () => {
    it('should auto flush after interval', async () => {
      logger = new BrowserLogger({ flushInterval: 100 });
      const flushSpy = vi.spyOn(logger, 'flush');
      
      logger.info('test');
      vi.advanceTimersByTime(100);
      
      expect(flushSpy).toHaveBeenCalled();
    });
  });

  describe('Browser Events', () => {
    it('should flush on beforeunload', () => {
      const flushSpy = vi.spyOn(logger, 'flush');
      
      window.dispatchEvent(new Event('beforeunload'));
      
      expect(flushSpy).toHaveBeenCalled();
    });
  });
});
```

## カバレッジ確認

```bash
# カバレッジ付きテスト実行
npm run test:logger:coverage

# カバレッジレポートの確認
open coverage/index.html
```

## 実装時の注意点

### 1. TDD原則の遵守
- **Red**: 失敗するテストを書く
- **Green**: テストが通る最小限のコードを書く
- **Refactor**: コードを改善する

### 2. カバレッジ目標
- **総合**: 80%以上
- **関数**: 85%以上
- **分岐**: 75%以上
- **行**: 80%以上

### 3. テストの質
- **境界値テスト**: 必須
- **エラーハンドリング**: 重要
- **非同期処理**: 適切な待機
- **モックの活用**: ブラウザAPI

### 4. パフォーマンス考慮
- **メモリリーク**: 防止
- **処理時間**: 測定
- **スループット**: 確認

## チェックリスト

### 実装前
- [ ] 要件定義の確認
- [ ] テスト戦略の理解
- [ ] 環境設定の完了

### 実装中
- [ ] 型定義の作成とテスト
- [ ] 設定機能の実装とテスト
- [ ] ロガー本体の実装とテスト
- [ ] カバレッジ目標の達成

### 実装後
- [ ] 全テストの実行
- [ ] カバレッジレポートの確認
- [ ] パフォーマンステストの実行
- [ ] CI/CDパイプラインの確認

---

このクイックリファレンスを参考に、効率的にテストを実装してください。